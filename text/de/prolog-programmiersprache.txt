Prolog (vom Französischen: programmation en logique, dt.: „Programmieren in Logik“) ist eine Programmiersprache, die Anfang der 1970er-Jahre maßgeblich von dem französischen Informatiker Alain Colmerauer entwickelt wurde und ein deklaratives Programmieren ermöglicht. Sie gilt als die wichtigste logische Programmiersprache.
Erste Implementierungen wichen in ihrer Syntax stark voneinander ab, aber der Edinburgh-Dialekt setzte sich bald als Quasistandard durch. Er war jedoch nicht formal definiert, bis er 1995 zur Grundlage eines ISO-Standards wurde (ISO/IEC 13211-1), der auch ISO-Prolog genannt wird.
Der erste Prolog-Interpreter wurde in Marseille in ALGOL W realisiert. Der erste Ansatz für einen Compiler stammte von David H. D. Warren aus Edinburgh. Dieser hatte als Zielsprache die des Logik-Prozessors Warren’s Abstract Machine und erlaubte deshalb weder dynamische Änderungen noch einen Anschluss rücksetzbarer Prädikate in anderen Programmiersprachen. Der erste voll nutzbare Compiler, der beides erlaubte, wurde von Preben Folkjaer und Christian Pichler in München entwickelt. Er verwandte einen anderen, von der TU Wien stammenden, Zwischencode, der inkrementell kompiliert wurde; wurden Prädikate verändert, wurde das Kompilat gelöscht und beim nächsten Aufruf neu kompiliert.
Prolog-Programme bestehen aus einer Wissensdatenbank, deren Einträge sich Fakten und Regeln nennen. Der Benutzer formuliert Anfragen an diese Wissensdatenbank.
Ein positives Resultat bedeutet, dass die Anfrage logisch ableitbar ist. Ein negatives Resultat bedeutet nur, dass aufgrund der Datenbasis keine Ableitung gefunden werden kann.
Das typische erste Programm in Prolog ist nicht wie in prozeduralen Programmiersprachen ein Hallo-Welt-Beispiel, sondern eine Wissensdatenbank mit Stammbauminformationen.
Das erste Faktum in Form einer  Aussage mann(tobias). liest sich als: Tobias ist ein Mann. vater(tobias, frank). definiert das Faktum: Tobias ist der Vater von Frank. Für Hinweise zum Laden von Prolog Texten siehe entsprechenden Abschnitt:
In einem Prolog-Interpreter können nun interaktiv Anfragen an die Datenbasis gestellt werden. Das Ausführen eines Prolog-Programms bedeutet immer das Stellen einer Anfrage.
Das System antwortet entweder mit yes. oder no., abhängig davon, ob die Anfrage bewiesen werden konnte.
Eine Anfrage mit einer Variablen liefert als Antwort zusätzlich Belegungen, mit denen die Anfrage wahr wird. Man nennt eine solche Variablenbelegung Unifikation und sagt, die Variable wird mit diesem Wert unifiziert. Variablen sind in Prolog Token, die mit einem Großbuchstaben beginnen:
Der Interpreter liefert nur positive Antworten auf Anfragen, die explizit definiert oder folgerbar sind (Closed world assumption). So liegen etwa über heinrich keinerlei Informationen in der Datenbasis:
Die Regel besagt: X ist Großvater von Y, wenn es ein Z gibt, sodass X Vater von Z ist und Z Vater von Y. Damit ist der Großvater väterlicherseits definiert.
Prolog kennt die Grundrechenarten, also Addition +, Subtraktion -, Skalarprodukt *, Division / und Modulo mod. Die Zuweisung eines Wertes zu einer Variable erfolgt mit dem Schlüsselwort is. Im Gegensatz zu imperativen Programmiersprachen können in Prolog Variablenwerte nicht überschrieben werden.
Listen sind rekursive Datenstrukturen bestehend aus einem Kopf (Head) und einem Rest (Tail). Der Rest kann hierbei wieder aus Listen bestehen.
Um zu prüfen ob ein bestimmtes Element in einer Liste enthalten ist, wird die vordefinierte Funktion member verwendet:
der Eingabezeile [user] tippen. Die Eingabe der Klauseln muss mit einem Dateienendezeichen abgeschlossen werden (^D oder ^Z je nach Plattform):
Alternativ kann ein Prolog-Text in einer Datei gespeichert werden und z. B. mit dem Prädikat consult geladen werden. Das Prädikat nimmt einen physischen Pfad zu einem Prolog-Text entgegen:
Entscheidend für die Prolog-Programmierung sind die Techniken der Rekursion und die Nutzung von Listen.
Ist die Rekursion in den meisten Programmiersprachen nur eine zusätzliche Variante zur Iteration, ist sie bei der Prolog-Programmierung die einzige Möglichkeit, Schleifen zu produzieren. Benötigt man in obigem Beispiel eine allgemeine Vorfahr-Relation, wird das wie folgt realisiert (";" zeigt in der Klausel die Disjunktion bzw. das logische „oder“):
Dies lässt sich wie folgt lesen: X ist ein Vorfahr von Z, wenn X Elternteil von Z ist (Regel 1) oder es ein Y gibt, das Vorfahr von Z ist und gleichzeitig X Elternteil von Y (Regel 2) (Es wurde hier elternteil statt mutter oder vater verwendet.)
Auch Listen sind ein entscheidender Bestandteil von Prolog. Die meisten Prolog-Implementationen bringen dafür viele Basisfunktionen mit („concat“ = Anhängen von Werten, „count“ = Anzahl der Werte, etc.), die sich aber auch alle selbst definieren lassen. In einer gedachten Familienstruktur muss die Anzahl der Kinder ja variabel sein. Folgendes wäre denkbar:
Dabei ist X die Variable, deren verschiedene Werte ausgegeben werden sollen. Der Unterstrich _ ist in Prolog die anonyme Variable, wodurch Prolog veranlasst wird hier jeden Wert zuzulassen. Die eckigen Klammern stehen für die leere Liste, welche die nicht vorhandenen Kinder repräsentiert.
Eine weitere Eigenschaft und Besonderheit gegenüber anderen Programmiersprachen ist, dass Prolog in der Lage ist, während der Laufzeit seine vorhandene Datenbank zu erweitern oder zu löschen. Ein Beispiel für das Löschen eines einzelnen Elements:
Zum Löschen aller gleichen Elemente (also z. B. auto()) auf einmal benutzt man retractall(), zum Ausgeben asserta() (oben in der Datenbank) und assertz() (unten in der Datenbank).
A bis H stehen jeweils für eine Ziffer 0 bis 9, wobei nicht klar ist, welche Ziffer welchem Buchstaben entspricht. Gesucht ist die Zahl, die bei den Fragezeichen stehen muss. Dieses Problem ist in Prolog sehr einfach zu lösen. Man schreibt zunächst eine Regel, die bewirkt, dass A bis H später mit allen möglichen Kombinationen von 0 bis 9 belegt werden (Permutation):
Nun müssen nur die fünf entstehenden Gleichungen (ABB – CD = EED, FD + EF = CE, ABB – FD = EGD, CD – EF = FH und EED * CE = EGD * FH = X) in Prolog-Syntax geschrieben werden:
Wird nun die Abfrage loesung. eingegeben, wird die Lösung ausgegeben. Wie man sieht, benötigt man zur Lösung dieses Problems fast keine Programmierkenntnisse über Schleifen oder ähnliches, sondern gibt nur die Fakten ein und welches Ergebnis man benötigt. Prolog steht in der Abstraktionshierarchie aus genau diesem Grund über imperativen und objektorientierten Sprachen.
Eine häufig gestellte Aufgabe an Programmiersprachen ist die Verarbeitung hierarchischer Strukturen, wie z. B. SGML oder XML. Insbesondere für XML bildet Prolog eine sehr wirkungsvolle und ausdrucksstarke Alternative zu der verbreitetsten Verarbeitungssprache XSLT.
wird unter Prolog als rekursive Liste von Elementen element(TagName, Attribute, Kinder) dargestellt.
Ein sehr einfaches Paradigma (untere drei Klauseln) erlaubt es, jeden Baum rekursiv zu durchlaufen. Folgende Beispiele löschen (oberste Klausel mit delete) und konkatenieren (zweite Klausel von oben mit concat) bestimmte Tags. Der erste Unifikator ist die Operation (delete oder concat), der zweite die zu bearbeitende Struktur, der dritte das spezifizierte Tag, der vierte der Ergebnisbaum. append ist ein Befehl zum Konkatenieren von Listen.
Stößt der Backtracker bei der Operation delete auf ein Tag, das wie das zu löschende heißt, so wird dieses entfernt und bei den Nachbarn weitergesucht. Ein entsprechender Aufruf ist z. B. transform(delete, Tree, autor, ResTree)., der alle Autoren entfernt.
Ähnlich können durch transform(concat, Tree, paragraph, ResTree). alle nebeneinanderstehenden Paragraphen miteinander verschmolzen werden. Dazu werden zunächst deren Inhalte konkateniert, daraus eine neue Paragraphstruktur erzeugt und diese weiterverarbeitet.
Planungssysteme suchen eine Möglichkeit, von einem Ausgangszustand in einen gewünschten Zielzustand zu gelangen. Sie lassen sich für die Suche von Straßen- oder Verkehrsverbindungen, aber auch für allgemeinere Problemstellungen einsetzen. Zunächst der allgemeinste Ansatz für eine blinde Tiefensuche (d. h. es ist unbekannt, ob der einzelne Schritt auch näher zum Ziel führt):
Nur die Prädikate operator, anwendbar, fuehrt_zu und zulaessig sowie die Beschreibung eines Zustands sind problemspezifisch zu formulieren. Aufgerufen wird das Prädikat mit einer Zustandsliste, die den Anfangszustand enthält.
Abhängig vom Problemtyp lässt sich einiges vereinfachen und/oder weglassen; für eine Wegesuche in einem Straßennetz ergibt sich z. B.
Bei realen Problemen führt eine blinde Suche selten zum Ziel; man benutzt eine Breitensuche, bei der alle vom Start aus erreichbaren neuen Zustände ermittelt, mit einer Heuristikfunktion bewertet und nur der beste (Heuristische Suche) oder eine sortierte Liste der besten (Best-first-Suche) weiterverfolgt werden. (Die einfache heuristische Suche kann dazu führen, dass nicht immer die optimale Lösung gefunden wird, da bestimmte Lösungsschritte, die fälschlicherweise als ungünstig aussortiert wurden, sich als bessere Lösung ergeben würden.) Die Kunst liegt in der richtigen problemspezifischen Formulierung der Heuristikfunktion. In vielen Fällen hilft die A-Heuristik, das ist die Summe aus bisher erbrachtem Aufwand und geschätztem Restaufwand zum Ziel (z. B. zurückgelegte Fahrtstrecke + Luftliniendistanz zum Zielort):
Jedes Element von BewerteteListe hat die Struktur [Heuristikwert,gesamte Fahrtstrecke,Ort]; zur Berechnung der A-Heuristik sind die bisherige Strecke, der letzte Ort und der Zielort (Luftlinie) erforderlich.
Dies ist eine Version des Zebrarätsels. Es wurde angeblich von Albert Einstein im 19. Jahrhundert verfasst. Einstein wird oft der Vermerk zugeschrieben, nur 2 % der Weltbevölkerung seien im Stande, das Rätsel zu lösen. Es existiert jedoch kein Hinweis auf jedwede Autorenschaft. Hier soll es ein Beispiel für ein Problem darstellen, das mit Prolog lösbar ist.
Jeder Hausbewohner bevorzugt ein bestimmtes Getränk, raucht eine bestimmte Zigarettenmarke und hält ein bestimmtes Haustier.
Keine der fünf Personen trinkt das gleiche Getränk, raucht die gleichen Zigaretten oder hält das gleiche Tier wie seine Nachbarn.Frage: Wem gehört der Fisch?
Um Regeln für Parser zu schreiben, haben die meisten Prologsysteme einen Präprozessor implementiert. Er erlaubt es, die Regeln in einer besser lesbaren Form zu notieren, die in der Form den Regeln entsprechen, die verwendet wird, um eine kontextfreie Sprache zu beschreiben. Der Präprozessor ergänzt Platzhalter und erzeugt die oben erwähnten Prolog-Logik-Formeln. Durch Übergabe weiterer Attribute ist es möglich, mit Definite Clause Grammars auch komplexere Sprachen als die kontextfreien zu beschreiben.
Ein Prolog-Programm ist eine geordnete Liste so genannter Horn-Klauseln, einer eingeschränkten Form der Prädikatenlogik erster Ordnung. Stellt man dem System eine Anfrage (Query), versucht es, diese auf der Grundlage dieser Datenbasis mittels Resolution zu beweisen. Das Ergebnis einer Query ist yes oder no. Seine eigentliche Wirkung entfaltet ein Prolog-Programm streng genommen durch Nebenwirkungen, die während der Beweissuche auftreten. Also kann ein Prolog-System auch als ein sehr effizienter – wenn auch eingeschränkter – automatischer Theorembeweiser verstanden werden. Die einzige in Prolog eingebaute Suchstrategie bei der Beweisfindung ist Tiefensuche mit Backtracking.
Die Sprache wird heute noch in den Bereichen Computerlinguistik und Künstliche Intelligenz verwendet. Zum Beispiel sind Sprachverarbeitungskomponenten des durch seinen Auftritt bei Jeopardy! bekannt gewordenen KI-Systems Watson in Prolog geschrieben. Außerdem gibt es einige kommerzielle Anwendungen im Bereich des Systemmanagements, bei denen asynchrone Ereignisse (Events) mit Hilfe von Prolog oder darauf basierenden proprietären Erweiterungen verarbeitet werden. Ein Beispiel hierzu ist das Produkt Tivoli Enterprise Console (TEC) von IBM, das auf IBM-Prolog basiert.
Erlang (begann als Prolog-Interpreter, auch die Syntax ist davon inspiriert, ebenfalls personelle Nähe, denn der Erfinder von Erlang Joe Armstrong hat am Swedish Institute of Computer Science (SICS) gearbeitet)
Patrick Blackburn, Johan Bos, Kristina Striegnitz: Learn Prolog Now! College Publications, 2006, ISBN 1-904987-17-6.
David L. Bowen, Lawrence Byrd, Fernando C. N. Pereira, Luís M. Pereira und David H. D. Warren: DECsystem-10 Prolog User’s Manual. Occasional Paper 27, 1982. Department of Artificial Intelligence, University of Edinburgh, Edinburgh, Scotland. (Download; Doc; 192 kB)
Hans Kleine Büning, Stefan Schmittgen: PROLOG: Grundlagen und Anwendungen. B.G. Teubner, Stuttgart 1986, ISBN 3-519-02484-5.
Ivan Bratko: Prolog Programming for Artificial Intelligence. 4. Auflage, Addison-Wesley, Harlow 2012, ISBN 0-321-41746-1.
William F. Clocksin: Clause and Effect. Prolog Programming for the Working Programmer. Springer, Berlin 2005, ISBN 3-540-62971-8.
William F. Clocksin, Christopher S. Mellish: Programming in Prolog. 5. Aufl., Springer, Berlin 2003, ISBN 3-540-00678-8.
Michael A. Covington, Donald Nute, André Vellino: Prolog Programming in Depth. Prentice Hall, 1996, ISBN 0-13-138645-X.
Esther König, Roland Seiffert: Grundkurs PROLOG fur Linguisten. UTB Linguistik, 1989, ISBN 3-7720-1749-5.
Leon S. Sterling, Ehud Shapiro: The Art of Prolog. Advanced Programming Techniques. 2. Aufl., MIT Press, Cambridge 1994, ISBN 0-262-69163-9.
Wilhelm Weisweber: Prolog. Logische Programmierung in der Praxis.  Thomson, 1997, ISBN 3-8266-0174-2.
Learn Prolog Now! Online-Buch mit Prolog-Einführung, auch für Programmieranfänger verständlich geschrieben. (engl.)
BProlog kommerzielles Prolog-System (kostenlos für Bildung und Forschung) mit Erweiterungen zur Constraintprogrammierung (CLP), Nebenläufigkeit und interaktive Graphen
Jekejeke Prolog ist eine reine Interpreterimplementation von Prolog, die vollständig in Java geschrieben wurde. Die Implementation der Sprache hält sich im Wesentlichen an den ISO Core Standard.
JIProlog ist ein als Shareware erhältlicher kommerzieller Prolog-Interpreter, der ISO-Kompatibilität anstrebt und in Java (J2SE, J2ME) läuft
SICStus Prolog kommerzielles, ISO-kompatibles Prolog-System vom Swedish Institute of Computer Science, erlaubt z. B. Constraintprogrammierung (englisch)
SWI-Prolog freies, quelloffenes (LGPL), umfassendes ISO-kompatibles Prolog-System mit gutem Community-Support (inkl.  Editor, Debugger, Profiler und zahlreichen Programmbibliotheken; englisch)
tuProlog ist ein freier, quelloffener (LGPL) Interpreter für eine Untermenge von Prolog in Java (J2SE, J2ME) und .NET
Ciao frei, quelloffen (LGPL), implementiert ISO Prolog, hat Spracherweiterungen für variable Prädikate (HiLog), constraintbasierte, objektorientierte und nebenläufige Programmierung (englisch)
ECLiPSe Constraint Programming System frei, quelloffen (MPL), Prolog-basiert mit Erweiterungen für Constraintprogrammierung und zusätzliche Suchstrategien (englisch)
Logtalk ist eine freie, quelloffene (Artistic License 2.0) objektorientierte logische Programmiersprache (englisch)
Mercury, eine stark an Prolog angelehnte Programmiersprache, vereint Elemente aus der funktionalen und der logischen Programmierung (englisch)
Poplog ist eine freie, quelloffene (XFree86-Lizenz), integrierte, interaktive Programmierumgebung mit inkrementellen Compilern für die Sprachen POP-11, Prolog, Common Lisp und Standard ML, die nicht nur multiparadigmatisches Programmieren, sondern auch das Mischen dieser Programmiersprachen ermöglicht (englisch)
QuProlog – ein erweiterter, freier Prolog-Compiler, der v. a. zum Implementieren interaktiver Theorembeweiser dient (englisch)
XSB freies, quelloffenes (LGPL), »fast« ISO-Prolog-kompatibles logisches Programmiersystem mit über Prolog hinausgehenden Spracherweiterungen (HiLog; volle, tabulierte Resolution; erweitertes Pattern Matching) und Bibliotheken für GUI-Programmierung, F-Logic und Ontologie-Verarbeitung (englisch)
