Extreme Programming (XP, auch Extremprogrammierung) ist eine Methode, die das Lösen einer Programmieraufgabe in den Vordergrund der Softwareentwicklung stellt und dabei einem formalisierten Vorgehen geringere Bedeutung zumisst.
Diese Vorgehensweise definiert ein Vorgehensmodell der Softwaretechnik, das sich den Anforderungen des Kunden in kleinen Schritten annähert.
XP ist ein durch fortlaufende Iterationen und den Einsatz mehrerer Einzelmethoden strukturierendes Vorgehensmodell. XP entstand durch die Synthese verschiedener Disziplinen der Softwareentwicklung und basiert auf in der Praxis bewährten Methoden, auch Best practices genannt.
XP folgt einem strukturierten Vorgehen und stellt die Teamarbeit, Offenheit und stete Kommunikation zwischen allen Beteiligten in den Vordergrund. Kommunikation ist dabei eine Grundsäule.
Die Methode geht davon aus, dass der Kunde die Anforderungen an die zu erstellende Software zu Projektbeginn noch nicht komplett kennt und nicht hinreichend strukturieren kann, beziehungsweise dass ein mit der Realisierung betrautes Entwicklerteam nicht über alle Informationen verfügt, um eine verlässliche Aufwandsschätzung über die notwendige Dauer bis zum Abschluss zu geben. Im Laufe eines Projektes ändern sich nicht selten Prioritäten und Gewichte. Zu Beginn geforderte Funktionen der Software werden möglicherweise in einer anderen Form benötigt oder im Laufe der Zeit sogar komplett hinfällig.
Bei einer konsequenten Ausrichtung an XP soll die zu erstellende Software schneller bereitgestellt werden sowie eine höhere Softwarequalität und Zufriedenheit des Kunden als mit traditionellen Ansätzen zu erreichen sein. Der Kunde soll ein einsatzbereites Produkt erhalten, an dessen Herstellung er aktiv teilgenommen hat.
Neue Funktionalitäten werden permanent entwickelt, integriert und getestet. Für die zu entwickelnden Funktionalitäten werden jeweils die Schritte Risikoanalyse, Nutzenanalyse, die Bereitstellung einer ersten ausführbaren Version (Prototyping) und ein Akzeptanztest durchgeführt.
Nach Vertretern dieses Vorgehensmodells ist XP Risikomanagement. Es bejaht das Risiko, geht aktiv darauf ein und versucht, es zu minimieren. Dieser implizite Umgang mit dem Faktor Risiko steht im Gegensatz zu eher expliziten Vorgehensweisen, wie der Aufstellung einer Risikoliste. Softwareentwicklungsprojekte sind unterschiedlichen Gefahren ausgesetzt, für die Extreme Programming Lösungen anbieten soll.
Dem Kunden bietet XP, gerade durch seine kurzen Entwicklungszyklen, jederzeit die Möglichkeit, steuernd auf das Projekt einzuwirken. Dadurch soll erreicht werden, dass sich das Produkt aktuellen Anforderungen anpasst, statt überholten Anforderungen aus einer längst vergangenen Analysephase zu genügen und damit bereits bei Einführung veraltet zu sein. Zudem kann der Kunde bereits nach kurzer Zeit ein unvollständiges aber zumindest funktionstüchtiges Produkt einsetzen. Der Kunde ist im besten Fall jederzeit auf demselben aktuellen Informationsstand bezüglich des Projektes wie das Entwicklerteam.
Ein häufiger Ansatz traditioneller Softwareerstellung ist: „Vielleicht brauchen wir irgendwann einmal diese oder jene Programmfunktionen“, auch Feature genannt. XP stellt dem gegenüber: Lass es! (vgl. auch YAGNI –„You Ain’t Gonna Need It“). Vor jedem der kurzen Entwicklungsschritte wird zusammen mit dem Kunden genau festgelegt, was wirklich sinnvoll ist, entwickelt zu werden. Die sogenannte „Featuritis“ soll damit vermieden werden.
Eines der größten Risiken der Softwareentwicklung ist, dass dem Kunden ein Produkt bereitgestellt wird, das er in dieser Form nicht möchte. XP möchte dem durch ständige, aktive Einbeziehung des Kunden in den Entwicklungsprozess vorbeugen. Er kann sich Zwischenversionen ansehen und direkt Änderungswünsche äußern.
Um diese Vorteile nutzen zu können, muss der Kunde im Gegenzug auch eine Reihe von Einschränkungen und Forderungen hinnehmen. So fordert XP von ihm, dass er während der gesamten Entwicklungszeit mit dem Entwicklungsteam zusammenarbeitet. Des Weiteren muss er auf eine formale Festlegung der Projektinhalte (Spezifikation) verzichten (siehe auch Der ideale Kunde).
Es existiert keine strikte Rollentrennung, da die Aufgabenverteilung abhängig von Situation und Fähigkeiten geschieht. Der allgemeine Wissensaustausch und die stetige Kommunikation beugen einem Wissensmonopol vor. Dies soll den Einzelnen entlasten, da ansonsten der Druck auf einer Person lastet, wenn diese sich als Einzige in einem Modul auskennt.
Um Unbenutzbarkeit aufgrund von Programmfehlern sowie fehlerhafte Integration einzelner Komponenten zu vermeiden, werden bei XP viele und möglichst frühe Tests angestrebt. Jede Komponente besitzt einen Modultest (Unit-Test); in Java beispielsweise mit JUnit. Bei Feststellung eines Fehlers in einer Komponente während der Entwicklung wird ein Test entwickelt, der diesen lokalisiert. Eine tägliche Einbeziehung der einzelnen am Projekt beteiligten Entwickler mit automatischer Ausführung der Tests (Regressionstest) soll zu einer erheblichen Qualitätssteigerung führen. Fehler sollen so früher gefunden werden, denn je später ein Fehler gefunden wird, desto teurer ist meist dessen Korrektur. Außerdem soll die testgetriebene Entwicklung zu einem leichter wartbaren Programmcode mit besserem Design führen.
Da die meisten Einzelmethoden gerade auf den Alltag der Programmierer ausgerichtet sind, bedeutet XP zugleich auch ein hohes Maß an Herausforderung und ggf. Umstellung der Beteiligten. Auf diese Aspekte wird ausführlicher im Abschnitt Der ideale Programmierer eingegangen.
Dem Projekt bietet XP die Möglichkeit, Risiken zu minimieren. Unter richtiger Anwendung von XP soll der Kunde Software erhalten, deren Umfang ihn nicht überrascht. Das Team soll ferner gegen Ausfall (Krankheit, Unfall, Stellenwechsel) Einzelner nicht mehr so anfällig sein. Ein ehrlicher Umgang mit dem Kunden soll die Glaubwürdigkeit und Zufriedenheit steigern und die Angst minimieren, die unter Umständen zwischen Kunde („Haben die mich verstanden?“, „Was werden sie wohl liefern?“) und Entwicklung („Was will er eigentlich genau?“, „Ob er zufrieden sein wird mit dem, was wir liefern?“) vorherrscht.
Aufwandsabschätzungen werden verlässlicher, da sie im Team getroffen und ständig einer kritischen Überprüfung (Review) unterzogen werden. Teamgeist wird laut XP gefördert. Jedem im Team sollte klar sein, dass das Ziel nur als Einheit erreichbar ist. Sollte ein Projekt, zum Beispiel aus Kostengründen, vorzeitig eingestellt werden, besteht durch die regelmäßigen Iterationen dennoch ein zumeist einsatzfähiges Produkt.
In vielen Projekten gelingt es nicht, das Produkt in der gewünschten Zeit im gewünschten Umfang und mit den geplanten Ressourcen fertigzustellen. In XP soll nur das verwirklicht werden, was tatsächlich einen Nutzen für den Kunden hat. Durch ständigen Austausch mit dem Kunden sowie Prioritätsanalysen sollen die unbedingt zu erstellenden Funktionen identifiziert werden. Dabei sollte mit den Funktionen begonnen werden, die den größten Nutzen haben und das größte (technische) Risiko beinhalten.
Extreme Programming stellt aus wirtschaftswissenschaftlicher Sicht eine Form der Organisation dar, die direkt die Prozesse der Wertschöpfung beschreibt. In den Wirtschaftswissenschaften werden zur Bewertung von Extreme Programming auch Erkenntnisse anderer Sozialwissenschaften, insbesondere der Soziologie, genutzt.
Dem Risikomanagement dient diese Alternative vor allem zur Steuerung von Risiken. Wie bei vielen Prozessen der Wertschöpfung sind besonders in der Softwareentwicklung Risiken meist operative Risiken: Die Wertschöpfung ist ineffektiv, wenn die Kundenwünsche nicht getroffen und gesteckte Ziele somit verfehlt wurden. Die Wertschöpfung ist ineffizient, wenn zum Erreichen des Ergebnisses ein zu hoher Aufwand entstand. Risikoverminderung, und dadurch Effektivität und Effizienz, soll bei Extreme Programming durch die Art des Umgangs mit Fehlern, mit Mitarbeitern und mit Kunden erreicht werden:
Weniger Fehler im ErgebnisEin möglichst genaues Erkennen von Risiken durch das Verfahren selbst soll über angepasste Aufwandsschätzungen eine Bewertung des zu akzeptierenden Risikos ermöglichen. Extreme Programming kann dagegen eine Risikoverlagerung erschweren. Aus der Sicht des Risikomanagements ist Extreme Programming also nur eine Möglichkeit, mit Risiken umzugehen, und zwar eine Möglichkeit, die Vor- und Nachteile besitzt.
Das Personalwesen in Unternehmen betrachtet Extreme Programming insbesondere im Hinblick auf seine Auswirkungen auf die Mitarbeiterzufriedenheit. Extreme Programming soll dabei bewusst oder unbewusst zum kooperativen Lernen beitragen. Für das Personalwesen ist dieses Verfahren also besonders aus Sicht der Personalentwicklung interessant. Durch höhere Mitarbeiterzufriedenheit und durch die Vermeidung von Überstunden soll die gesamte Produktivität erhöht werden. Die Praktik des Pair-Programming lässt allerdings – rein mathematisch betrachtet – Gegenteiliges vermuten. Die Vermeidung von Spezialistentum und individuellem Besitz von Wissen über Teile der Software dient der kollektiven Wissenskonstruktion und kann die Ersetzung von Entwicklern vereinfachen.
Die gesamte Betriebswirtschaftslehre ist in den letzten Jahren von der prozess- bzw. wertschöpfungsorientierten zur kunden- bzw. marktorientierten Unternehmensführung übergegangen. Auch wenn Extreme Programming die Wertschöpfung beschreibt, bietet es Möglichkeiten zu kundennaher Vorgehensweise. Über Extreme Programming soll – wie in anderen Branchen schon länger üblich – eine größere Einbindung des Kunden in den Wertschöpfungsprozess möglich sein. Wichtig wird dies umso mehr, wenn Software weniger als Faktorgut, sondern mehr als Vorprodukt erstellt und vertrieben wird.
Ebenfalls betrachtet werden muss Extreme Programming und dessen Aufwand aus Sicht des Informationsmanagements, das den Aufwand für den unbedingt notwendigen Informationsaustausch festlegt und ökonomisch bewertet. Genutzt werden dazu Erkenntnisse der Informations- und Kommunikationswissenschaft. Dabei kann insbesondere die Medienreichhaltigkeitstheorie eingesetzt werden: Weil die zu diskutierenden und kommunizierenden Sachverhalte in der Regel komplex sind, werden auch komplexe, reichhaltige Kommunikationsmedien gewählt: direkte, persönliche Gespräche. Kritisch zu hinterfragen ist hierbei die schwierige räumliche Verteilbarkeit der Entwicklungsprozesse sowie die Einbindung des Kunden, da unter Umständen eine räumliche Trennung zwischen Entwicklern und Kunden besteht.
Vereinzelt wird Extreme Programming als informelle (und damit unverbindliche) Methode bezeichnet. Das trifft jedoch weder den Ansatz noch das Ziel. Tatsächlich ist die Formalisierung der Methode des Extreme Programming bewusst flach und schlank gehalten. Hingegen muss ein Einvernehmen zwischen Kunden und Programmierern hinsichtlich der Verbindlichkeit der erstellten Unterlagen hergestellt werden, solange diese noch nicht durch neuere Fassungen ersetzt wurden. Weiter muss der Vorgang des Ersetzens einer Fassung einer Unterlage durch eine neuere Fassung dieser Unterlage soweit formalisiert sein, dass beide Parteien Kenntnis von dieser Ersetzung haben und diese Ersetzung annehmen.
Neben dem Entwicklungsteam gibt es im Wesentlichen den Kunden und den Product-Owner. Innerhalb des Entwicklerteams soll es keine Rollentrennung geben. So wird nicht unterschieden, wer im Team welches Spezialgebiet hat, beziehungsweise welche besonderen Fähigkeiten er mitbringt. Jede Person im Team wird als Entwickler (Developer) bezeichnet. Ein Manager ist gewöhnlich eine Person mit Führungsbefugnis, also ein disziplinarischer Vorgesetzter. Dieser hat in XP weniger Wichtigkeit. Dagegen gibt es einen „Leiter“ des Teams, also jemand, der die Kommunikation mit Kunden oder untereinander koordiniert. Auch der Nutzer der zu erstellenden Software kann das Team durch das Projekt führen. Die Unterscheidung zwischen Manager und „Leiter“ ist für agile Vorgehensmodelle typisch. Der Product-Owner, der über die genaue Vorgehensweise entscheidet, trägt die Verantwortung. Product-Owner im Sinne von XP kann beispielsweise ein Vertreter des Produktmanagements, ein Kunde oder ein Nutzer des Produktes sein. Die Rollen sind je nach Projekt und Umgebung unterschiedlich, häufig auch in Personalunion, verteilt.
Der Umgang mit den Anforderungen und deren Verwirklichung ist eine zentrale Komponente XPs. Durch eine Mischung verschiedener, in den folgenden Abschnitten dargestellter Maßnahmen soll die Qualität und Flexibilität der Software gesteigert werden, so dass sich der Zusammenhang zwischen dem Zeitpunkt der Anforderungsstellung und den damit entstehenden Kosten weitgehend linear darstellt.
Bei einem weitgehend linearen Verlauf einer ableitbaren Änderungskostenkurve wird auf eine vollständige Erhebung aller Anforderungen zu Beginn des Projektes verzichtet. Stattdessen werden die sich erst im Laufe der Umsetzung ergebenden Anforderungen berücksichtigt. Dieses Vorgehen resultiert aus den Beobachtungen, dass einerseits der Kunde zu Beginn des Projektes noch gar nicht genau weiß, was er möchte, andererseits sich diese Anforderungen im Laufe eines Projektes ändern. Darüber hinaus sind Fehler umso teurer, je später man sie findet. Im schlimmsten Fall erhält der Kunde nach einem langen Projekt etwas geliefert, was er in dieser Form gar nicht haben möchte. Ständiger Gedankenaustausch mit dem Kunden, Offenheit für Änderungen und stetige Integration wirken diesen Risiken entgegen. Anforderungen werden nicht selten zunächst als Prototypen bereitgestellt. Dabei handelt es sich um Versionen, die noch nicht die volle, endgültige Funktionalität besitzen.
Im Rahmen der Planung wird gewöhnlich folgende Unterscheidung vorgenommen: ein Release beinhaltet die Funktionen, die insgesamt und für sich geschlossen die Bereitstellung einer neuen Version des Produktes rechtfertigen. Um zu dem Release zu kommen, ist ein Release-Plan aufzustellen, der im Wesentlichen aus Iterationen besteht. Unter anderem abhängig von der geschätzten Entwicklungsdauer des Release werden die Iterationen in Anzahl und Dauer festgelegt. Iterationen dauern üblicherweise zwischen einer und vier Wochen. Der Zeitpunkt der Fertigstellung wird als Zeitintervall diskutiert, dessen Größe im Laufe des Release aufgrund gewonnener Erkenntnisse und des durchgeführten Fortschritts ständig abnimmt.
Die innerhalb der Iterationen umzusetzenden einzelnen Neuerungen werden mit dem Kunden durch User-Storys beschrieben.
Das ganze Team ist bei der Erstellung beteiligt. Die abzuarbeitenden Anforderungen werden auf einzelnen Karten (Story Cards) geschrieben und für alle sichtbar platziert. Neben diesem Vorgehen ist es auch üblich Class Responsibility Collaboration Models auf CRC Cards zu verfassen. CRC Models nehmen sich dabei einen Akteur im System vor und beschreiben dessen Verantwortlichkeiten und Interaktionen mit anderen Akteuren.
Den User-Storys werden Prioritätswerte zugeordnet. Dazu muss das Team zusammen mit dem Kunden zunächst Klarheit gewinnen, welche User-Storys das höchste Risiko bezüglich Zeitplan, Kosten oder Funktionalität besitzen und welche User-Storys dem Produkt den höchsten, respektive den niedrigsten Mehrwert bieten, wobei ein Diagramm hilfreich sein kann. Das Release sollte mit den User-Storys begonnen werden, die das höchste Risiko und den höchsten Nutzen auf sich vereinen. Danach sind diejenige User-Storys zu verwirklichen, die geringes Risiko aber hohen Nutzen haben. Anschließend geht das Team die User-Storys an, die geringes Risiko und geringen Nutzen auf sich vereinen. Die Fertigstellung von User-Storys mit geringem Nutzen aber hohem Risiko ist zu vermeiden.
Neben einer Abschätzung nach Nutzen und Risiko ist für die Entscheidung, welche User-Storys in dem Release beziehungsweise in den ersten Iterationen umgesetzt werden sollen, noch eine Analyse der Kundenwünsche von Bedeutung. Dabei bedient sich ein XP-Projekt häufig des Kano-Modells. Dabei werden in einer systematischen Kundenbefragung Fragen in funktionaler Form und in dysfunktionaler Form gestellt. Es lässt sich anschließend bestimmen, welche User-Storys unbedingt fertiggestellt werden müssen (Must-haves), welche linearer Natur sind (je mehr, desto besser; siehe linear.) und welche Exciters sind (Der Kunde rechnet nicht mit diesen Merkmalen, nutzt das Produkt auch ohne. Es lässt sich dadurch der Preis erhöhen.). Die so gewonnenen Erkenntnisse werden diskutiert.
XP zeichnet sich dadurch aus, dass die Betrachtung der Größe einer Einheit, wie Release oder Iteration, unabhängig von ihrer Dauer ist.
Bei der Release-Planung sind User-Storys noch recht grobkörnig. Beschäftigt sich ein Team mit einer User-Story genauer, so wird sie, zusammen mit dem Kunden, detaillierter beschrieben. User-Storys werden gewöhnlich in Story-Points abgeschätzt, wobei auch eine Abschätzung in idealen Tagen möglich ist. Story-Points sind relative Aufwandsabschätzungen, also der Entwicklungsaufwand für eine Story im Vergleich zu anderen. Dabei kann es sein, dass erste Abschätzungen im Verlaufe des Projektes geändert werden. Es wird vom ganzen Team, in mehreren Runden, in einem Planning-Game eine Punkteanzahl für die User-Storys geschätzt.
Nachdem User-Storys abgeschätzt, priorisiert und einer Iteration zugewiesen wurden, beginnt das Team mit der Umsetzung. User-Storys werden zu Beginn der Iteration in feinkörnige, technische Arbeitspakete (Tasks) zerlegt, die gewöhnlich einen Umfang von Stunden besitzen. Das Team führt diese Zerlegung durch und schätzt die Dauer eines jeden Tasks. Es wird allerdings noch nicht festgelegt wer den Task zugeteilt bekommt. Zu Beginn der Arbeiten nehmen sich die Entwickler jeweils ein Arbeitspaket vor, gewöhnlich nach Fähigkeiten. Dieser Vorgang wird im Team kurz diskutiert. Nach der anfänglichen Zuweisung der Arbeitspakete wird ein weiterer Task begonnen, wenn ein Teammitglied Zeit dafür findet, also seinen vorangegangenen Task abgeschlossen hat. Die Implementierung einer User-Story, also der Funktionalität, ist erst abgeschlossen, wenn alle einzelnen Tasks dieser User-Story abgearbeitet und die Tests geschrieben und alle erfolgreich durchlaufen sind.
Der Demonstration dieser Vorgehensweise soll eine Tabelle mit Aufwandsabschätzungen in einer fiktiven Arztpraxis dienen. Jeder Arzt hat eine Software, die ihm hilft, seine Patienten und die Termine zu verwalten:
Der Begriff Velocity (Geschwindigkeit) beschreibt den Durchsatz des Teams, also die Anzahl der innerhalb einer Iteration erreichten Story-Points. Die Bestimmung der Velocity hilft abzuschätzen, wie lange die Entwicklung der gewünschten Funktionalität für ein Release dauert, beziehungsweise wie viele Iterationen notwendig sind. Es ist normal, dass die Geschwindigkeit des Teams nicht immer die gleiche ist.
Es gibt eine tägliche kurze Besprechung (Stand-up Meeting), bei der jeder Entwickler berichtet, was er am Vortag geleistet hat, wo es gegebenenfalls Probleme gab und was er heute leisten möchte. Ferner werden situationsabhängig Arbeitspaare gebildet (Pair-Programming). Im Laufe des Tages findet, während die Entwickler die Funktionalität und die Tests programmieren, weiterer stetiger Austausch (Pair-Negotiations) statt.
Kann eine User-Story in einer Iteration nicht abgeschlossen werden, zum Beispiel weil die Tests nicht erfolgreich waren oder sich die Abschätzung als zu knapp beziehungsweise der Umfang als zu groß herausgestellt hat, so wird sie gewöhnlich in mehrere kleinere aufgeteilt oder komplett in die nächste Iteration verschoben. Auch während einer Iteration kann sich, durch sich ändernde Prioritäten des Kunden oder durch neue Erkenntnisse, an der Zusammenstellung der Iteration etwas ändern. Ist die Iteration abgeschlossen, schauen sich Vertreter des Managements, der Kunde (Akzeptanztest) oder andere Personen, die an dem Produkt Interesse haben, das Produkt in der aktuellen Ausbaustufe an und geben Rückmeldungen. So ist es denkbar, dass der Kunde während des Akzeptanztests neue Prioritäten setzt oder weitere Ideen einbringt.
Technische Unterstützung muss differenziert betrachtet werden. Einerseits wird bewusst auf technische Hilfsmittel verzichtet, so etwa bei der Erstellung von User-Storys. Diese werden gewöhnlich manuell erstellt. Andererseits wird die Technik aber auch exzessiv genutzt, so etwa bei der automatisierten Integration und der automatisierten Durchführung von Tests. Darüber hinaus existieren Projektmanagement-Werkzeuge, die sich auf die speziellen Rahmenbedingungen und Anforderungen XPs konzentriert haben.
Die zu entwickelnde Funktionalität wird kurz und formlos in User-Storys beschrieben. Das meiste Wissen über die Funktionalität ihrer Entwicklung befindet sich in den Köpfen der Beteiligten. User-Storys werden gewöhnlich nur relativ zueinander geschätzt. Zu Beginn einer Iteration wird deren Inhalt festgelegt. Anschließend kommt erst die Aufteilung der gewählten User-Storys in Tasks. Neuartig an dem XP-Ansatz ist ebenfalls, dass nicht nur einzelne Personen, sondern das ganze Team den jeweiligen Aufwand schätzt. Auch das Verfahren der Schätzung ist neu. Der Zeitpunkt, wann und wie die Tasks den einzelnen Entwicklern zugeteilt werden, ist ebenfalls ein Abgrenzungskriterium. Erst im Laufe der Iteration nehmen sich die einzelnen Entwickler, je nach ihrer Verfügbarkeit, eines Tasks an. Zu allen User-Storys gibt es zahlreiche Tests. Eine User-Story ist erst komplett abgeschlossen, wenn alle Tests erfolgreich abgelaufen sind. Der tägliche kurze Austausch ist für die agile Methodik üblich.
XP besteht aus Werten, Prinzipien und Praktiken. Obwohl es auch andere maßgebliche Quellen gibt (siehe Weblinks und Literatur), orientiert sich die Zusammenstellung der Werte, Prinzipien und Praktiken an Kent Beck, dessen noch recht neue, evolutionäre Weiterentwicklungen XPs hier ebenfalls Berücksichtigung finden. Es existiert keine eindeutige Definition von XP, wobei allerdings die Diskussionen und Ausführungen der drei Originalverfasser XP am signifikantesten prägen.
XP definiert fünf zentrale Werte, abstrakte Elemente, die von zentraler Bedeutung sind: Kommunikation, Einfachheit, Rückmeldung, Mut und Respekt, wobei Respekt erst später dazukam. Ohne stetige Beachtung dieser zentralen Werte ist es laut XP nicht möglich, erfolgreich Software zu entwickeln.
Das Team kommuniziert stetig, um Informationen auszutauschen. Der Prozess selbst erfordert hohe Kommunikationsbereitschaft. Es gibt einen stetigen Austausch aller Beteiligten, also auch zwischen dem Entwicklungsteam und dem Kunden. Es kommen auch Personen zu Wort, die in einer gerade diskutierten technischen Aufgabenstellung keine Experten sind. So werden sie miteinbezogen, es gibt zusätzliche Rückmeldungen und jeder fühlt sich dem Team und dem Produkt verpflichtet. Stetige Kommunikation mit dem Kunden, Aufnahme seines Feedbacks und Erfüllung seiner Wünsche, also auch eines lauffähiges Produktes, das seinen Wünschen voll entspricht, ist wichtiger als Vertragsverhandlungen. Die Kommunikation zeichnet sich ferner durch einen respektvollen Umgang aus, sowohl im Team untereinander als auch mit dem Kunden. Unterschiedliche Meinungen werden akzeptiert.
Die Entwickler sollen mutig sein und die Kommunikation offen gestalten. Falls eine Anforderung nicht in einer Iteration umgesetzt werden kann, wird in offener und ehrlicher Art und Weise direkt darauf hingewiesen. Es muss eine Atmosphäre geschaffen werden, die herkömmliche Störungen (wie unnatürlichen Konkurrenzkampf innerhalb des Teams zu Lasten des Produktes) minimiert. Um die Offenheit und den Mut zu fördern und gruppendynamischen, psychologischen Schwierigkeiten entgegenzutreten, kann bewusst ein Doomsayer zur offenen, zeitnahen Aussprache von schlechten Nachrichten oder möglichen Schwierigkeiten oder auch ein Advocatus Diaboli eingesetzt werden.
Es soll die einfachste Lösung für eine Problemstellung umgesetzt werden. In jeder Iteration konzentriert sich das komplette Team genau auf die momentan umzusetzenden Anforderungen. Die Lösungen sind technisch immer möglichst einfach zu halten.
Es gibt 14 Prinzipien, die eine Brücke bilden zwischen den abstrakten Werten und den konkret anwendbaren Praktiken. Diese Prinzipien sollten immer Berücksichtigung finden. Sie sind Menschlichkeit, Wirtschaftlichkeit, Beidseitiger Vorteil, Selbstgleichheit, Verbesserungen, Vielfältigkeit, Reflexion, Lauf, Gelegenheiten wahrnehmen, Redundanzen vermeiden, Fehlschläge hinnehmen, Qualität, Kleine Schritte sowie Akzeptierte Verantwortung.
Software wird von Menschen entwickelt. Menschen bilden also den Faktor, dem laut XP besondere Aufmerksamkeit gilt. Durch Schaffung einer menschlichen Atmosphäre soll den Grundbedürfnissen der Entwickler (Sicherheit, Vollendung, Identifikation mit der Gruppe, Perspektive und Verständnis) entsprochen werden.
Die erstellte Software beziehungsweise eine einzelne Funktionalität muss einerseits wirtschaftlich sein und dennoch einen echten Wert bringen. Andererseits muss sie für beide Seiten von Vorteil sein und alle Beteiligten (Entwicklungsteam und Kunde) zufriedenstellen.
Die Wiederverwendung bestehender Lösungen, wozu beispielsweise die zahlreichen unterschiedlichen Tests gehören, die stetig automatisiert durchlaufen werden, ist wichtig.  Es ist jedem klar, dass erste Lösungen meist nicht optimal sind. Aus Feedback und selbst gewonnenen, neuen Erkenntnissen wird die Lösung stetig verbessert. Immer bessere Lösungen zu erkennen, gelingt nur durch stetige Reflexion und ein kontinuierliches Hinterfragen der jeweiligen Vorgehensweisen im Team. Die Produktivität dieses Verfahrens steigt proportional zur Uneinheitlichkeit des aus Personen mit unterschiedlichen Fähigkeiten und Charakteren bestehenden Teams. Verschiedene Meinungen werden nicht nur geduldet, sondern sogar gefördert. Dazu muss ein Konfliktmanagement etabliert werden.
Die Lauffähigkeit der Software muss zu jedem Zeitpunkt garantiert sein. Obwohl kurze Iterationen mit permanentem Feedback dabei helfen, das Projekt in einem Lauf zu halten, müssen Fehlschläge dennoch miteinkalkuliert werden. Es ist durchaus üblich und wird akzeptiert, eine Umsetzung durchzuführen, die zunächst nicht optimal oder sogar fehlerhaft sein kann. Diese Schwierigkeiten müssen als Gelegenheit und Chance begriffen werden, das Produkt und das Team noch weiter reifen zu lassen. Ein offener, konstruktiver Umgang mit den Herausforderungen der Softwareentwicklung gelingt umso besser, je mehr alle Beteiligten bereit sind, ihre Verantwortung zu akzeptieren. Einem Entwickler eine Aktivität und Verantwortung nur disziplinarisch aufzutragen, reicht nicht aus, da er die Verantwortung aktiv annehmen und leben muss.
Ein weiterer wichtiger Punkt ist die hohe Qualität, die gemäß XP im Gegensatz zu anderen Faktoren wie Ressourcen, Funktionsumfang oder Endtermin nicht zur Diskussion steht. Diese Grundeinstellung unterscheidet sich von vielen anderen Methoden der Softwareerstellung, bei denen Software zu einem bestimmten Zeitpunkt und in einem definierten Funktionsumfang fertiggestellt werden soll, worunter fast immer die Softwarequalität leidet. Gerade die Qualität ist allerdings wichtig, um das Produkt einsatzfähig, fehlerfrei und erweiterbar zu halten. Software mit gutem Design und hoher Qualität ist mittelfristig kostengünstiger, erweiterbarer und weniger fehlerbehaftet als schnell erstellte, sogenannte Quick-and-dirty-Software.
Zu guter Qualität gehört auch die Vermeidung von Redundanzen (unnötig mehrfach oder wiederholt ausgeführte oder auch manuell ausgeführte automatisierbare Schritte).
Durch schnelle, kleine Schritte bleibt das Team flexibel und kann sich schnell neuen Rahmenbedingungen anpassen und auf Feedback eingehen. Die negativen Folgen eines einzelnen kleinen, nicht erfolgreichen Schrittes können wesentlich schneller durch einen neuen Schritt kompensiert werden, als dies bei einem einzelnen größeren Schritt der Fall wäre.
Es lassen sich traditionelle und evolutionäre Praktiken unterscheiden. Die traditionellen sind in der XP-Welt weit verbreitet und genutzt. Die evolutionären nehmen verschiedene neue Erkenntnisse aus der jahrelangen Anwendung XPs auf. Sie verfeinern oder modifizieren die ursprünglichen Praktiken geringfügig und machen damit die Nutzung klarer und verständlicher.
Bei der Paarprogrammierung teilen sich zwei Programmierer einen Computer – einer codiert (der Driver) und der andere denkt mit und hat das Gesamtbild im Kopf (der Partner). Die Rollen werden regelmäßig getauscht. Dieses Vorgehen steigert den Wissenstransfer. Anfänger sollen schneller von der Arbeit eines Spezialisten lernen. Das Wissen wird verteilt. Das Projekt ist nicht mehr so anfällig gegen den Ausfall eines Einzelnen. Durch ständigen Codereview der Entwicklung und Kommunikation wird das Design verbessert und Fehler schneller gefunden (siehe auch Vier-Augen-Prinzip).
Aktivitäten werden zunächst nicht an einzelne Personen verteilt, sondern an das ganze Team. Es existiert laut Methodik das Bewusstsein und die Verpflichtung nur als Team erfolgreich sein zu können. Einzelne Teammitglieder besitzen kein Wissensmonopol. Pair-Programming und wechselhafte Einsatzgebiete sollen der Strömung entgegenwirken, dass einzelne Personen Teile als ihren Besitz betrachten.
Kontinuierliche Integration der einzelnen Komponenten zu einem lauffähigen Gesamtsystem in kurzen Zeitabständen. Je häufiger integriert wird, desto höher wird laut XP die eintretende Routine. Fehler werden damit früh aufgedeckt. Die mit der Integration verbundenen Kosten sollen fast auf Null minimiert werden, da die Integration zu einem täglichen Schritt gehört, der weitestgehend vollautomatisiert und selbst stabil und durchgetestet sein muss.
Bei der testgetriebenen Entwicklung werden erst die Modultests (Unit-Test) geschrieben, bevor die eigentliche Funktionalität programmiert wird. Der Entwickler befasst sich dadurch früh mit dem Design des Codes und überdenkt seine Programmierarbeit genau. Die Tests werden nach jedem Programmierschritt ausgeführt und liefern Rückmeldung über den Entwicklungsstand. Die Tests sind automatisiert. Im Laufe einer Integration werden Integrationstests durchgeführt. Es wird zwischen Regressionstest und Modultest unterschieden. Während Modultests (Unit-Tests) einzelne Module testen, ist ein Regressionstest die kollektive Ausführung aller Tests, um die unveränderte Lauffähigkeit der alten, bereits vor der Iteration existenten Funktionalität zu überprüfen. Auch Performancetests, bei denen die Leistungs- und Geschwindigkeitsmerkmale in Bezug auf die geforderten Werte gemessen werden, sind üblich. Der Entwickler bekommt Rückmeldung (Feedback), wie viele und welche Tests nicht erfolgreich waren. Ein Akzeptanztest ist die Präsentation des Standes des Produktes, um die Zufriedenheit des Kunden und die Nutzbarkeit zu validieren.
Enge Einbeziehung des Kunden, das heißt, der Kunde gibt das Iterationsziel mit einer Auswahl der zu realisierenden User-Storys vor und hat kurz danach die Möglichkeit, Akzeptanztests durchzuführen. Story-Cards dienen als Medium, um die kurzen Anwendungsfälle in Form von User-Storys aufzunehmen. Der Kunde muss immer anwesend oder zumindest erreichbar sein. Neben User-Storys auf Story-Cards existiert noch der Ansatz, CRC-Modelle auf CRC-Karten zu verfassen.
Laufendes Refactoring, ständige Architektur-, Design- und Code-Verbesserungen, auch um Anti-Patterns umgehend erkennen und beseitigen zu können. XP bejaht die Existenz von Code, der am Beginn nicht perfekt ist. Stattdessen sind sämtliche Teile einem stetigen Review unterworfen. Gefundene, optimierungsfähige Stellen werden gewöhnlich sofort verbessert oder als Fehler (Bugs) definiert, die in einer späteren Iteration behoben werden.
40-Stunden-Woche, d. h. Überstunden sind zu vermeiden, weil darunter die Freude an der Arbeit, mittelfristig die Konzentrationsfähigkeit der Programmierer und somit auch die Qualität des Produktes leidet. Nachweislich sinkt die Produktivität eines Entwicklers durch Überstunden. Arbeit außerhalb der regulären Arbeitszeit wird im Einzelfall zwar geduldet, aber auf keinen Fall besonders entlohnt oder erwartet. Überstunden zeugen gewöhnlich einfach nur von falscher Planung.
Kurze Iterationen, um dem Kunden in regelmäßigen Zeitabständen einen lauffähigen Zwischenstand des Produkts zu liefern. Eine Iteration ist eine zeitlich und fachlich in sich abgeschlossene Einheit. Kurze Iterationen und damit verbundene Akzeptanztests erlauben schnelle Feedbackschleifen zwischen Entwicklung und Kunde.
Da in traditionell aufgesetzten Softwareprojekten ein latentes Missverständnis zwischen Kunde und Entwicklungsteam ein häufiges Problem darstellt – der Entwickler hat Schwierigkeiten mit der Fachsprache des Kunden und umgekehrt –, werden die Anforderungen im fachlichen Vokabular des Kunden, idealerweise auch von ihm selbst, in Form von User-Storys beschrieben. Alle sprechen eine Sprache, was durch ein Glossar noch verstärkt werden kann. Es wird eine Metapher gewählt, eine inhaltlich ähnliche, für beide Seiten verständliche Alltagsgeschichte.
Das Team hält sich bei der Programmierarbeit an Standards, welche erst die gemeinschaftliche Verantwortung des Teams bei dieser Aufgabe ermöglichen. Wechselnder Einsatz der Entwickler in allen Bereichen der Software ist laut XP nur durch gemeinsame Standards sinnvoll möglich.
Es soll die einfachste Lösung angestrebt werden, also diejenige, die genau das Gewünschte erreicht (und nicht mehr). Bewusst allgemein (generisch) gehaltene Lösungen oder vorbereitende Maßnahmen für potentiell zukünftige Anforderungen werden vermieden. Zum Thema Einfachheit sind die umgangssprachlichen Akronyme KISS („Keep it simple, stupid“) und YAGNI („You Ain’t Gonna Need It“) verbreitet.
Neue Versionen der Software werden in einem Planning-Game, auch als Planning-Poker bekannt, spezifiziert und der Aufwand zu deren Umsetzung abgeschätzt. An diesem iterativen Prozess sind sowohl Entwicklungsmannschaft als auch Kunde beteiligt.
Die evolutionären Praktiken wurden fünf Jahre nach den ursprünglichen publiziert und ersetzen diese. Sie lassen sich unterteilen in Hauptpraktiken und ergänzende Begleitpraktiken. Inhaltlich sind die neuen Praktiken mit den alten, traditionellen Praktiken vergleichbar. Die Bezeichnungen der alten Praktiken wurden teilweise modifiziert oder in einzelne Unterpraktiken aufgeteilt. Zwei Praktiken sind weggefallen: die Praktik Metapher war zu schwer zu vermitteln und hat sich laut Literatur nicht durchgesetzt. Coding-Standards werden als selbstverständlich vorausgesetzt und nicht mehr explizit erwähnt.
Die Hauptpraktiken sind: Räumlich zusammen sitzen, Informativer Arbeitsplatz, Team, Pair-Programming, Energievolle Arbeit, Entspannte Arbeit, Storys, Wöchentlicher Zyklus, Quartalsweiser Zyklus, 10-Minuten-Build, Kontinuierliche Integration, Test-First-Programmierung und Inkrementelles Design.
Durch offene, gemeinsame Anordnung der Arbeitsplätze soll die Kommunikation optimiert werden. Diese Form ist aufgrund der besseren Kommunikationsmöglichkeiten einer räumlichen Trennung der Beteiligten vorzuziehen. Der Arbeitsplatz muss ferner „informativ“ sein, indem zum Beispiel aktuelle Tasks, der Stand des Projektes und andere wichtige Informationen vom Arbeitsplatz aus immer gut sichtbar sind. Empfehlenswert ist es hier zum Beispiel, die User-Storys zentral an einer Wand anzubringen.
Das Team ist laut XP wichtiger als die Individuen. Es fällt, im Bewusstsein, nur als Gemeinschaft erfolgreich zu sein, gemeinsame Entscheidungen. Dies wird dadurch gefördert, dass die einzelnen technischen Aktivitäten in der Planung nicht einzelnen Personen, sondern dem Team zugeordnet werden. Probleme löst das Team ohne den Eingriff eines Managers von außen. Mit dem Thema selbstregulierendes Team befasst sich auch der Essay Die Kathedrale und der Basar. Pair-Programming mit abwechselnden Partnern soll diese Grundeinstellung weiter fördern.
Die Arbeit soll mit voller Motivation und gleichzeitig in einer entspannten, kollegialen Atmosphäre ablaufen, da die Entwickler ohne Überstunden arbeiten und somit maximale Produktivität erreicht wird. Es werden Sicherheitspuffer einkalkuliert. Nicht einhaltbare Versprechen werden vermieden.
Die zu entwickelnde Funktionalität wird in Form von Storys beschrieben, beispielsweise User-Storys. In wöchentlichem Zyklus wird entschieden, welche Kundenwünsche als Nächstes in Angriff genommen werden. Das Projekt selbst wird in einem quartalsweisen Zyklus geplant. Die vorgegebenen Zyklen sind Richtwerte, deren Größen im täglichen Einsatz variieren können.
Die Software zu erstellen und alle Testläufe durchzuführen soll in maximal zehn Minuten abgeschlossen sein. Durch diesen 10-Minuten-Build werden die Kosten für Erstellung und das Testen der Software minimiert. Alle von einem Entwickler gemachten Änderungen sollten circa alle zwei Stunden bereitgestellt werden. Diese kontinuierliche Integration soll einem potentiellen Chaos vorbeugen, das entstehen könnte, wenn die Entwickler ihre Änderungen und Erweiterungen am Produkt selten in das zentrale Datenhaltungssystem (Repository) einstellen würden. Alle Mitarbeiter haben so die Änderungen rasch zur Verfügung. Sowohl die zehn Minuten beim Build als auch die zwei Stunden bei der Integration sind Zielvorgaben, die in konkreten Projekten variieren können. Gerade bei großen Projekten mit einer großen Menge an Quelltext und Entwicklern wird ein Build deutlich länger dauern, und die Integrationsintervalle werden oft größer sein. Die Praktiken betonen nur die Richtung und geben einen Idealwert vor, der angestrebt werden sollte. Durch Automatisierung lässt sich die Build-Zeit weitestgehend minimieren.
Die Entwicklung ist gekennzeichnet durch den Test-First-Programmieransatz: vor der Realisierung der Funktionalität muss der Test geschrieben werden. Ein inkrementelles Design, das neue Erkenntnisse und Feedback aufnimmt, verbessert das Design der Software stetig.
Zahlen-pro-Nutzung.Der Kunde nimmt aktiv an der Entwicklung teil. Er ist Teilnehmer an den regelmäßigen Treffen und wird aktiv miteinbezogen. Die Einbeziehung zeigt sich auch beim zu entwickelnden Funktionsumfang, der verhandelbar bleiben muss. Mehrere kleinere Verträge anstatt eines großen Vertrags können in derartig betriebenen Projekten Risiken minimieren und die Flexibilität erhöhen. Da iterativ stetig neue Versionen bereitgestellt werden, müssen die Zahlungen des Kunden unabhängig von der Anzahl der bereitgestellten Versionen sein. Der Kunde zahlt nicht für jede Version der Software, sondern pro Nutzung.
Das Team soll einerseits von seiner Konstanz leben, kann aber auch personell verkleinert werden. Das Entwicklerteam muss über mehrere Projekte hinweg das gleiche sein. Es erwirbt im Rahmen der Produktentwicklung die Fähigkeiten, als Team zusammenzuarbeiten, welche für weitere Projekte genutzt werden kann. Sobald das Team leistungsstärker und produktiver wird, sollte seine Arbeitslast, trotz einer Verlagerung von Ressourcen zu anderen Teams, konstant bleiben.
Dem Code als dem im Zentrum stehenden Medium kommt eine zentrale Rolle zu. Er wird in einer zentralen, datenbankähnlichen Struktur (Repository) gehalten. Es existiert nur eine offizielle Version (Codebasis) des Systems. Dieser Code wird, bildlich gesprochen, zwischen den Entwicklern geteilt. Jeder Entwickler im Team muss in der Lage sein, auch „fremden“ Code jederzeit ändern zu können (Collective-Code-Ownership). Neben dem Code existieren immer die Tests, die zusammen mit dem Code die einzigen zu erstellenden, durch die Entwicklungsarbeit bereitgestellten Medien („Artefakte“) sind. Alle anderen Medien, zum Beispiel die Dokumentation, werden allein aus Code und Tests generiert.
Um Schwierigkeiten früh zu identifizieren, wird inkrementelles Deployment (die Überführung der Anwendung auf das Zielsystem) durchgeführt. Wenn Altsysteme durch neue Software ersetzt werden sollen, muss ein Teil nach dem anderen ersetzt werden. Dieses Vorgehen soll die Umstellung planbarer machen. Das Deployment ist täglich inkrementell durchzuführen. Jeden Tag soll eine neue Version der Software produktiv gestellt werden. Dies macht das Deployment zur Routine, minimiert dessen Kosten und Fehler und ermöglicht stetige Integrations- und Akzeptanztests. Falls einmal ein technisches Fehlverhalten eintritt, muss eine ursächliche Analyse durchgeführt werden.
Eine der theoretischen Grundlagen des Extreme Programming ist der Flexibilitätsgrad des zu entwickelnden Softwaresystems. XP geht von einem mindestens proportionalen Zusammenhang zwischen dem Gegenteil der Flexibilität, der sogenannten Steifheit, und den Pflegekosten zur Fehlerbehebung oder Erweiterung des Systems aus. Je flexibler ein Softwaresystem, desto geringer sind die Pflegekosten, je steifer, desto höher.
Ein schwerfälliges GesamtsystemDie Flexibilitätskriterien sind das Gegenteil der Steifheitskriterien, zum Beispiel ein leicht verständlicher und flexibler Entwurf.
Einige der als Bestandteil des Extreme Programming definierten Mechanismen dienen laut XP der Erhöhung der Flexibilität:
Die testgetriebene Entwicklung sorgt für ein ausreichendes Vorhandensein von Regressionstests und eine verbesserte Testbarkeit der Software
Das ständige Refactoring führt zur Fehlerbeseitigung, einem leicht verständlichen und flexiblen Entwurf sowie guter Dokumentation
Um die zu entwickelnde Funktionalität zu bestimmen, und zwischen Kunde und Entwicklungsteam auszuarbeiten, werden User-Storys eingesetzt
XP ist ein Vertreter der agilen Softwareentwicklung. Im Vergleich zu traditionellen Vorgehensmodellen wählt es alternative Ansätze, um Herausforderungen während der Softwareentwicklung zu adressieren.
In aus heutiger Sicht traditionellen Vorgehensmodellen ist der Softwareentwicklungsprozess in aufeinanderfolgenden Phasen organisiert. Nach Jahren der Anwendung von traditionellen Vorgehensmodellen, wie dem ab 1970 genutzten Wasserfallmodell, haben es, aus Sicht der XP-Vertreter, Projektverantwortliche nur unzureichend verstanden, die Probleme und Risiken der Softwareentwicklung in den Griff zu bekommen. Viele Projekte kamen nie zu einem Abschluss oder überstiegen zeitlich und/oder kostenmäßig die Planung. Viele, gerade über lange Zeiträume laufende Projekte deckten mit Abschluss zwar die zu Beginn spezifizierten Anforderungen ab, berücksichtigten allerdings unzureichend, dass Anforderungen sich ändern können oder erst im Laufe eines Projektes dem Kunden wirklich klar ist, wie das Endergebnis aussehen soll. Über Erfolg und Schwierigkeiten von Softwareprojekten liefert der Chaos-Report von The Standish Group regelmäßig fundierte Untersuchungen, wie beispielsweise 1994.In Abgrenzung zu traditionellen Vorgehensmodellen durchläuft der Entwicklungsprozess in XP immer wieder iterativ in kurzen Zyklen sämtliche Disziplinen der klassischen Softwareentwicklung (zum Beispiel Anforderungsanalyse, Design, Implementierung, Test). Durch diese inkrementelle Vorgehensweise werden nur die im aktuellen Iterationsschritt benötigten Merkmale verwirklicht (implementiert). XP ist dadurch leichtgewichtiger: Es wird keine komplette technische Spezifikation der zu entwickelnden Lösung vorausgesetzt (so gibt es beispielsweise kein Pflichtenheft).
Extreme Programming, und damit einher Standards wie JUnit, wurden von Kent Beck, Ward Cunningham und Ron Jeffries während ihrer Arbeit im Projekt Comprehensive Compensation System bei Chrysler zur Erstellung von Software entwickelt. Die Arbeiten am sogenannten C3-Projekt begannen 1995 und wurden 2000 nach der Übernahme durch Daimler eingestellt. Die dabei entwickelte Software wurde im Bereich der Lohnabrechnung eingesetzt und basierte hauptsächlich auf Smalltalk. Das C3-Projekt wurde ursprünglich nach dem Wasserfallmodell umgesetzt. Nachdem nach knapp einem Jahr kein wesentlicher Fortschritt zu verzeichnen war, wurde der Entwicklungsansatz geändert. Das Projekt zeichnete sich aus durch häufig wechselnde Anforderungen und einer hohen Mitarbeiterfluktuation.XP ist ein agiles Vorgehensmodell. Die folgende Tabelle stellt den von XP identifizierten Kerndisziplinen den historischen, weitverbreiteten Ansatz mitsamt seinen Risiken der Softwareentwicklung gegenüber. Unternehmen, die XP nicht einsetzen, können Vorgehensmodelle verwenden, die sich – bewusst oder unbewusst – mit diesen Disziplinen positiv auseinandersetzen.
Aufgrund der wachsenden Nutzung wird XP weiter optimiert: je mehr Projekte gemäß XP entwickelt werden, desto mehr Erfahrungen fließen in die Weiterentwicklung von XP ein. Da es auch eine Summe von Best practices ist, lässt sich somit sagen: „Es wird in der Praxis für die Praxis angepasst“.
Das Eingehen auf Änderungen hat Vorrang vor strikter PlanverfolgungNeben XP hat auch Scrum einen gewissen Bekanntheitsgrad erlangt. Neben vielen Ähnlichkeiten mit XP gibt Scrum in bestimmten Bereichen Vorgaben bezüglich Iterationslänge, Protokollierung und Verfahren. Scrum nutzt ein eigenes Vokabular.
Eine weitere gerne in diesem Zusammenhang angeführte Disziplin ist das Feature Driven Development, eine Methodik, die den Schwerpunkt ebenfalls auf die bereitzustellende Funktionalität legt.
Ähnlichkeiten zwischen XP und Kaizen, einem in Japan vor allem in der Autoindustrie entwickelten Konzept (Kontinuierlicher Verbesserungsprozess) zur Sicherung der Qualität im Fertigungsprozess und einer Optimierung der Fertigungs- und Managementkosten mittels „schlankerer“ Ansätze (Schlanke Produktion), sind nicht zu übersehen.
Ein weiteres agiles Vorgehensmodell ist Crystal, eine Familie von Methoden, deren Mitglieder meist mit Farben gekennzeichnet werden.
Auch traditionelle Vorgehensmodelle, wie das V-Modell, wurden zwischenzeitlich um neue Erkenntnisse in der Softwareentwicklung angereichert. Als Ergebnis bedient sich der Nachfolger, das V-Modell XT, agiler Ansätze. So gibt das V-Modell XT keine strikte Sequenz an zu durchlaufenden Phasen mehr vor.
Heute, über zehn Jahre nach den ersten XP-Schritten, erfreuen sich XP und andere agile Methoden wachsender Beliebtheit. Untersuchungen von „Forrester Research“ ergaben, dass in Nordamerika und Europa 2005 circa 14 % aller Projekte mit agilen Methoden durchgeführt wurden (von denen XP die verbreitetste ist) und viele andere einen Einsatz prüfen.
Zu den Nutzern XPs zählen sowohl Unternehmen, die kommerziell Software herstellen und vertreiben, als auch Unternehmen, deren eigentliches Geschäft nicht die Erstellung von Software ist: Dresdner Kleinwort Wasserstein, Encyclopaedia Britannica, Fidelity, Progressive, Capital One, Royal & Sunalliance, Channel One, Daedalos International, Gemplus, it-agile, Qwest und O&O Services.Viele Unternehmen berichten öffentlich von ihren Erfahrungen mit XP. Sie schildern, wie sie XP im Detail eingesetzt haben, welche Schwierigkeiten dabei auftraten und wie der Erfolg einzuschätzen war. Symantec hat seine Änderung des Vorgehensmodells hin zu XP publiziert. Sabre Airline Solutions hat mit XP sowohl die Fehler in ihrer Software als auch die Entwicklungszeit reduziert:
Gemäß einigen Protagonisten des XP-Ansatzes wirken die einzelnen Methoden so eng zusammen, dass diese ohne Ausnahme eingesetzt werden sollen. Bereits der Verzicht auf einzelne Methoden soll die Wirksamkeit des Gesamtansatzes massiv einschränken. Da jedoch der Einsatz der Methoden oftmals auf zahlreichen Voraussetzungen basiert (siehe z. B. die Abschnitte Der ideale Kunde und Der ideale Programmierer), ist es wahrscheinlich, dass in konkreten Projekten einzelne Methoden eben gerade nicht angewandt werden können. Das liefert dann auch auf einfache Weise eine Erklärung für das Scheitern von XP-Projekten: Meist dürfte sich eine vernachlässigte Methode finden lassen, so dass das Scheitern nicht auf XP als Gesamtansatz, sondern auf die Vernachlässigung dieser Methode zurückgeführt werden kann. Mittlerweile ist es umstritten, ob tatsächlich alle Methoden angewendet werden müssen, um durch XP die Wahrscheinlichkeit auf einen erfolgreichen Projektverlauf zu erhöhen.
Ein Hauptgrund für die Spezifikation von Anforderungen besteht bei klassischen Vorgehensmodellen in der Schaffung einer verlässlichen Basis für die Entwicklungsarbeit, so dass später notwendige Änderungen an der Realisierung möglichst gering bleiben. Die implizite Annahme dieser Haltung ist, dass Änderungen umso teurer werden, je später sie durchgeführt werden müssen. Obwohl sich diese Annahme in vielen Projekten bestätigt hat, geht XP gewissermaßen davon aus, dass Änderungen grundsätzlich „billig“ sind, wenn man sie kontinuierlich durchführt. Auch verneint XP implizit die Annahme, dass spätere Änderungen teurer werden, und begründet dies damit, dass die Änderungen dann nicht – wie in anderen Ansätzen – in mehreren Artefakten zugleich (Spezifikation, Dokumentation, Quellcode) umgesetzt werden müssen.
Die diesbezüglichen Annahmen von XP treffen sicher dann zu, wenn die Anforderungen unvermeidlich Änderungen unterworfen sein werden. In diesem Fall kann eine Spezifikation der Anforderungen unter Umständen größeren Aufwand nach sich ziehen als das Auslassen der Spezifikation – schon allein deswegen, weil die Spezifikation immer mitgeändert werden muss. Es ist jedoch unklar, warum es schädlich sein sollte, Anforderungen zumindest dann zu spezifizieren, wenn sie mit einiger Sicherheit bis zum Projektende Bestand haben werden. Durch den Verzicht auf eine Spezifikation läuft man Gefahr, Anforderungen zu übersehen oder hinsichtlich ihrer Bedeutung falsch einzuschätzen. Auch ist denkbar, dass der Kunde im Projektverlauf seine Anforderungen bewusst ändert, jedoch gegenüber dem Entwicklungsteam bekundet, seine Auffassung sei bislang nur falsch verstanden worden. Hinsichtlich der Einschätzung, dass spätere Änderungen nicht teurer sind als frühe, ist einzuwenden, dass späte Änderungen dann sehr teuer sein können, wenn sie das Design der Anwendung in grundlegender Weise betreffen. So ist die Änderung der Architektur einer Anwendung nicht ohne erheblichen Aufwand durchzuführen, ja sie kann ggf. teurer sein als eine Neuimplementierung. Es ist nicht ersichtlich und erscheint daher als eine Glaubensfrage, ob XP durch den Einsatz seiner Methoden derartige Situationen verhindern kann.
Der Einsatz von XP verlangt einen experimentierfreudigen Kunden, der nicht nur auf eine Reihe von üblichen Vorgehensweisen verzichten, sondern zudem selbst erhebliche Ressourcen aufwenden muss. Zu den Aspekten, auf die ein Kunde ungern verzichtet, gehören:
Software kann in komplexen Systemlandschaften eingeführt werden, so dass unterschiedlichste Beteiligte (z. B. Schnittstellenverantwortliche, Mitarbeiter von externen Providern usw.) Kenntnis von technischen Details erlangen müssen. In solchen Umgebungen verbieten meist schon die Firmenrichtlinien den Verzicht auf eine ausführliche Dokumentation. Aber selbst wenn dies nicht der Fall ist, bleibt zu klären, wie die Kenntnisse über technische Details an die Betroffenen vermittelt werden sollen, wenn keine Dokumentation existiert, und mehr noch, wenn davon ausgegangen werden muss, dass künftige Änderungen die relevanten technischen Einzelheiten betreffen.
Insbesondere beim Abschluss von Werkverträgen stellt sich für den Kunden die Frage, worin präzise eigentlich das Gewerk besteht, das durch den vereinbarten Preis erworben wird. Des Weiteren können firmenweite Richtlinien die Erstellung einer Spezifikation verlangen.
Da der projektleitende Vertreter des Kunden oftmals selbst den Projektfortschritt berichten muss, stellt die Fertigstellung bestimmter Funktionen zu festgelegten Terminen, somit also die Aufstellung eines Projektplans, oftmals einen unverzichtbaren Bestandteil der gemeinsamen Vorgehensweise dar.Über diese Punkte hinaus stellt das „Kunde vor Ort“-Prinzip eine Anforderung dar, die in der Realität nur äußerst selten umsetzbar ist. Um seine Aufgabe erfüllen zu können, muss der Mitarbeiter offensichtlich über einen erheblichen Wissensumfang verfügen. Ist dies aber der Fall, so ist der Mitarbeiter sehr wahrscheinlich auch in seinem eigenen Unternehmen nicht für mehrere Monate entbehrlich. Nicht selten werden IT-Projekte zudem gerade deshalb an externe Dienstleister vergeben, um den eigenen Ressourcenaufwand zu beschränken. Das Kunde-vor-Ort-Prinzip stellt somit eine der am schwierigsten erfüllbaren Anforderungen des Extreme Programming dar.
Die Programmierer müssen über sehr gute Fähigkeiten verfügen, da der auf häufigen Änderungen basierende Ansatz unter Verwendung von Refactorings nicht ohne umfangreiche Programmiererfahrung und ohne den Einsatz von dafür geeigneten Werkzeugen realisiert werden kann.
Programmierer weisen oftmals ein recht ausgeprägtes Ego auf, das sich in großer Überzeugung von „richtigen Lösungen“ und einem gewissen Besitzdenken hinsichtlich des geschriebenen Codes äußert. Nicht alle Programmierer können damit umgehen, dass – gemäß XP – jeder den Code aller anderen modifizieren darf.
XP weist eine Reihe von Merkmalen auf, die hohe Disziplin erfordern (wie z. B. der Test-first-Ansatz, das permanente Durchführen von Refactorings, Programmieren in Paaren usw.), und einige andere, die eine gewisse Disziplinlosigkeit fördern (z. B. das Auslassen von Spezifikation und Dokumentation). Es besteht die Gefahr, dass die letzteren Ansätze gegenüber den Ersteren betont werden. Die Einhaltung der Ansätze mit hoher Disziplin erfordert fähige Beteiligte und eine funktionierende Selbstregulierung des Teams. Da aber unter Umständen kein Projektverantwortlicher benannt wurde, fragt sich, wer letztlich für die konsequente Einhaltung aller Aspekte sorgt.Die Anforderungen zeigen, dass XP nicht auf beliebige Teams angewandt werden kann.
Mehrere XP-Methoden erfordern einen hohen Grad an gegenseitiger Informiertheit und somit ein hohes Maß an Kommunikation zwischen den Beteiligten. So bedingt das kontinuierliche Refactoring unter Umständen Änderungen gemeinsam genutzter Komponenten, über die möglichst das gesamte Team unterrichtet sein muss. Das Fehlen eines Projektmanagers erfordert gemeinsame Absprachen zur Arbeitsteilung. Da zudem eine präzise Spezifikation und Dokumentation fehlt, müssen alle Informationen zur Umsetzung in den Köpfen der Beteiligten verfügbar sein. Mit der Größe des Teams steigt jedoch der Kommunikationsaufwand quadratisch an, so dass XP-Projekten eine natürliche Grenze hinsichtlich der Teamgröße gesetzt ist. Die maximale Größe wird gemeinhin bei zehn Teammitgliedern angesetzt.
Ein weiterer häufiger Kritikpunkt ist, dass XP für Festpreisprojekte nicht geeignet sei. Da der Kunde einen festen Preis zahlt, muss der Auftragnehmer in irgendeiner Form sicherstellen, dass er für diesen Preis auch nur eine festgelegte Leistung erbringen muss. Die Leistungserbringung so lange bis der Kunde zufrieden ist kann in immer neuen Kundenanforderungen münden, so dass die Aufwände für die Realisierung nicht abzusehen sind. Die Festlegung der Festleistung als Inhalt des Werkvertrages entspräche jedoch einer Spezifikation und ist somit in XP verpönt. Es gibt einige Ansätze, XP dennoch mit Festpreisprojekten kompatibel zu machen:
besondere Preismodelle wie Aufwandspreis mit Obergrenze, Phasenfestpreis oder Anforderungseinheitspreis.Die Wirksamkeit dieser Ansätze ist jedoch unklar. User-Storys können zu unpräzise sein, um das Gewerk gegen unerwartete technische Anforderungen abzusichern. Die angesprochenen Preismodelle entsprechen nur noch bedingt einem Festpreis und damit Werkvertrag, so dass fraglich ist, ob ein Kunde mit der Vorgabe eines Festpreises darauf eingehen würde. Selbiges gilt auch für Versicherungsprämien.
Die iterative Vorgehensweise von XP und der fehlende Projektplan legen bereits nahe, dass die Fertigstellung eines fachlich gewünschten Funktionsumfangs zu einem gesetzten Termin nicht ohne weiteres garantiert werden kann. Zwar wird zu dem gesetzten Termin etwas fertig sein (da der Fokus jeder Iteration auf einer ausführbaren, ggf. sogar produktionsfähigen Software liegt), welche fachlichen Aspekte dies jedoch tatsächlich sind, kann nicht vorherbestimmt werden – umso weniger als Überstunden verpönt sind und das Ausmaß nötiger Refactorings auf Grund beweglicher Anforderungen nur schwer abgeschätzt werden kann.
XP gilt in verteilten Umgebungen als schwerer einsetzbar als herkömmliche Modelle. Der direkte Kontakt der Entwickler untereinander und zum Kunden ist problematisch, falls verschiedene Kunden existieren oder die Beteiligten räumlich getrennt arbeiten, so zum Beispiel bei teilweise ausgelagerten Entwicklungen (Outsourcing).
Die stets erneute Erstellung von Testfällen und die automatisierte, permanente Ausführung der Tests kann in komplexen oder nebenläufigen Anwendungen und verteilten Systemen aufwändig sein. Wenn sich keine Rollen ausbilden, muss jeder alles wissen, statt einzelne Schwerpunkte im Team zu setzen (klassisches Beispiel: GUI-Entwicklung und Datenbank-Entwicklung), was die Gesamtleistung des Teams vermindern kann.
Da das Team im Vordergrund steht, dürfen einzelne Entwickler nicht nach dem Umfang ihrer entwickelten Funktionalität honoriert werden. Insbesondere der Honorarvertrag ist kein geeignetes Vergütungsmodell bei Anwendung des Vorgehensmodells der XP.
Scott W. Ambler, Ronald E. Jeffries: Agile Modeling: Effective Practices for eXtreme Programming and the Unified Process. Wiley, John & Sons, ISBN 0-471-20282-7.
Kent Beck: Extreme Programming – das Manifest. Die revolutionäre Methode für Softwareentwicklung in kleinen Teams, Addison-Wesley, 2000, ISBN 3-8273-1709-6.
Kent Beck, Cynthia Andres: Extreme Programming Explained, Embrace Change. Addison-Wesley, 2. Auflage, 2004, ISBN 0-321-27865-8.
Ronald E. Jeffries: Extreme Programming Adventures in C#. Microsoft Press, 2004, ISBN 0-7356-1949-2.
Ronald E. Jeffries et al.: Extreme Programming Installed. Addison-Wesley Professional, 2000, ISBN 0-201-70842-6.
Henning Wolf, Stefan Roock, Martin Lippert: eXtreme Programming: eine Einführung mit Empfehlungen und Erfahrungen aus der Praxis. dpunkt, 2., überarb. u. erw. Aufl., 2005, ISBN 3-89864-339-5.
Michael Hüttermann: Agile Java-Entwicklung in der Praxis (mit intensiver Diskussion agiler Entwicklung insbesondere Extreme Programming): O’Reilly, 2007, ISBN 3-89721-482-2.
