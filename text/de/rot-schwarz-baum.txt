Ein Rot-Schwarz-Baum, auch RS-Baum oder RB-Baum, (englisch red–black tree oder RB tree) ist eine Datenstruktur vom Typ binärer Suchbaum, die „sehr schnellen“ Zugriff auf die in ihr gespeicherten Werte garantiert. Rot-Schwarz-Bäume wurden zuerst 1972 von Rudolf Bayer beschrieben, welcher sie symmetric binary B-trees nannte. Der heutige Name geht auf Leonidas J. Guibas und Robert Sedgewick zurück, die 1978 die rot-schwarze Farbkonvention einführten. Die schnellen Zugriffszeiten auf die einzelnen im Rot-Schwarz-Baum gespeicherten Elemente werden durch zwei Forderungen erreicht, die die Balance des Baums in einer Weise definieren, dass die Höhe eines Baums mit 
   sein kann. Somit können die wichtigsten Operationen in Suchbäumen – Suchen, Einfügen und Löschen – garantiert in 
Zusätzlich zu den Eigenschaften des binären Suchbaums hat jeder Knoten des Rot-Schwarz-Baums ein weiteres Attribut, genannt Farbe, das zwei Werte annehmen kann, genannt rot (engl. RED) und schwarz (engl. BLACK). Diese Einfärbung hat die folgenden zwei Forderungen zu erfüllen:
Werden der Datenstruktur Rot-Schwarz-Baum Operationen zum Zugriff und zur Verwaltung beigegeben, so werden diese nur dann als zugehörig angesehen, wenn sie die Rot-Schwarz-Forderungen aufrechterhalten, indem sie insbesondere den Baum nach einer modifizierenden Operation überprüfen und wenn nötig reparieren. So erweitert wird die Datenstruktur zu einem Abstrakten Datentyp (ADT). Bei Suchbäumen gibt es im Englischen dafür auch die Charakterisierung als self-balancing tree.
   schwarzer Knoten wird die Schwarztiefe des Baums genannt. Als Schwarzhöhe eines Knotens (engl. black-height) wird die einheitliche Anzahl schwarzer Knoten auf allen Pfaden zu den Pfadenden im von ihm gewurzelten Teilbaum bezeichnet. Nach dieser Definition ist ein Knoten der Schwarzhöhe 0 ein rotes Blatt, wie bspw. die Knoten 
   die Schwarztiefe des Baums, dann gibt es wegen der Forderung S#= auf einem Pfad von der Wurzel zu einem Pfadende genau 
   schwarze Knoten, aber wegen der Forderung !RR höchstens einen roten Knoten mehr als schwarze, also insgesamt maximal 
  , so dass der Rot-Schwarz-Baum immer gut genug balanciert – auf jeden Fall so gut, dass das Verhältnis zwischen der Höhe 
   beschränkt bleibt. Diese logarithmische Beschränkung, die im § #Höhenbeweis formal bewiesen wird, ist aber gleichzeitig das informationstheoretische Optimum, d. h. es gibt keinen Binärbaum mit kleinerer maximaler Pfadlänge (= Höhe) 
Bei den herausgehobenen Operationen Suchen, Einfügen und Löschen ist der auf einer Ebene des Baums anfallende Aufwand konstant. Also ist die Laufzeit höchstens proportional zur Anzahl der Knoten in einem Pfad, die wieder durch die Höhe limitiert ist, welche ihrerseits durch den Logarithmus der Knotenzahl limitiert ist.
Dieser Artikel nimmt die im Artikel Binärer Suchbaum in dessen Abb. 1A aufgezeigte und bei vielen Baumstrukturen übliche Sichtweise ein, bei der die Knoten die Schlüssel tragen („knotenorientierte Speicherung“), unabhängig davon, ob sie interne Knoten oder (interne) Blätter sind.Sehr verbreitet in der Literatur über Rot-Schwarz-Bäume ist die im Artikel Binärer Suchbaum in dessen Abb. 1B gezeigte Sichtweise, bei der die (ebenfalls knotenorientiert) die Schlüssel tragenden Knoten als intern angesehen werden, dem Baum aber zusätzliche Knoten als externe Blätter angeheftet sind, die an den Pfadenden für die (randlosen) Intervalle zwischen den Schlüsseln stehen (engl. auch „missing nodes“).In dieser zweiten Sichtweise kommt für die externen Blätter, genannt „NIL-Knoten“, eine dritte Forderung hinzu, und die Forderungen lauten:
Jeder Pfad von einem gegebenen Knoten zu einem seiner NIL-Knoten enthält die gleiche Anzahl schwarzer Knoten.
Hier haben die (internen) die Schlüssel tragenden Knoten immer genau zwei Kinder.Diese zweite (in mathematischer Hinsicht äquivalente) Sichtweise hat für das Verständnis der Sachverhalte einen vernachlässigbaren Nutzen, ihr Einfluss auf die Implementierung ist jedoch eher ungünstig.
Die Navigationsoperationen, das sind die verschiedenen Suchoperationen, das Traversieren, Aufsuchen erstes oder letztes Element und ähnliche, lassen den Baum unverändert (nur lesender Zugriff) und funktionieren im Prinzip auf jedem binären Suchbaum. Die dortigen Algorithmen und Angaben zur Komplexität gelten genauso für Rot-Schwarz-Bäume – mit der Präzisierung, dass die Höhe des Rot-Schwarz-Baums sich immer logarithmisch zur Anzahl der Knoten verhält.
Das Suchen eines Elements (oder einer Lücke) anhand seines Schlüssels ist die wichtigste unter den Navigationsoperationen. Die Höhen-Balancierung des Rot-Schwarz-Baums versucht, auf diese Operation hin zu optimieren. Sie ermöglicht eine Art „direkten Zugriff“ (im Gegensatz zum sequentiellen Zugriff der Traversierung). Sie wird in der Regel als vorausgehende Operation bei den Modifikationsoperationen (Einfügen oder Löschen) eingesetzt.
Das Suchen setzt eine totale Quasiordnung auf der Menge der Schlüssel voraus, die am flexibelsten durch eine Vergleichsfunktion realisiert wird.
   in den Rot-Schwarz-Baum sind dieselben wie bei einem binären Suchbaum: Der Zeiger zum neuen Knoten ersetzt einen Nullzeiger, der an einem Pfadende steht und als Indikator für das Fehlen entweder der Wurzel, falls der Baum leer ist, oder – bei einem Schlüssel tragenden Knoten 
Im unten stehenden Beispielcode wird angenommen, dass diese Richtung, die das letzte Ungleich-Ergebnis einer Suche nach dem Schlüssel von 
Ferner wird angenommen, dass diese Suchfunktion den Stapel struct node* Parents[] der Vorfahren von 
   gebildet hat. Wenn der Baum nicht leer ist, ist Parents[0] gleich dem Zeiger auf den Wurzelknoten.
   wird zunächst rot gefärbt, damit die Schwarztiefe des Baumes erhalten bleibt.Die darauf folgenden Aktionen überprüfen, ob die Rot-Schwarz-Balance im Baum eingehalten ist und stellen sie wenn erforderlich wieder her.
Der Kopf der Funktion RBinsert1 zum Einfügen eines Knotens nach einer vorher erfolgten und nicht erfolgreichen Suchoperation könnte wie folgt aussehen:
Zweimal  auf einer Zeile der Zusammenschau oder in einem Diagramm bedeutet beidesmal dieselbe Knotenfarbe, schwarz oder rot.
In den Diagrammen stellen die nummerierten Dreiecke regelkonform angebundene Rot-Schwarz-Teilbäume dar. Diese Teilbäume haben alle dieselbe Schwarztiefe, die
Die möglichen Konstellationen lassen sich in sechs Fälle aufteilen, zu denen es Transformationen (enthaltend Rotation und/oder Umfärbung) gibt, die entweder auf der betrachteten Ebene oder über weitere Iterationsschritte auf höheren Ebenen zu einer Reparatur (Rebalancierung) des Baumes führen.
die Konstellation nach Transformation und ggf. Zuweisung in der Spaltengruppe Ergebnisenthält. Eine Konstellation besteht aus fünf Gegebenheiten, und zwar aus den vier Farben der Knoten 
  , und zwar steht „o“ (wie engl. outer) für eine Rechts-Rechts- oder Links-Links-Kindesrichtung von 
Die Konstellationen in der Gruppe Bedingung genügen der Schleifeninvariante, und ihre logische Summe schöpft diese zu 100 % aus.
Die Transformation, deren Fallnummer in der Spalte Fall → verlinkt ist, transformiert die Eingabe-Konstellation (linke Seite im zum Fall gehörigen Diagramm) in eine andere auf der rechten Seite des Diagramms. Steht ein Häkchen „✓“ in der Spalte → Test, dann reflektiert die Gruppe Ergebnis diesen Stand, mit dem alle Rot-Schwarz-Forderungen erfüllt sind und mit dem die Einfügeoperation abgeschlossen ist.
Andernfalls steht dort die Fallnummer derjenigen Bedingung, auf die die transformierte und neu zugewiesene Konstellation zu testen ist, wobei die entsprechende Zuweisung, angegeben für den Problemknoten 
In der Spalte → Test kommt der Eintrag „E0“ nur bei der Transformation_E5 vor. Er bedeutet ggf. einen neuen Iterationsschritt, der mit dem Test auf die while-Bedingung_E0 in der do while-Schleife beginnt, und zwar zwei Baumebenen (eine Schwarzebene) näher an der Wurzel.
   (mit oder ohne Suchen). Die reine Rebalancierung ist gemäß § #Durchschnittliche und amortisierte Laufzeit im Mittel und amortisiert in 
Bei einem Eintrag in der Spalte Rotation ist eine Rotation an der Transformation beteiligt. Man entnimmt der Tabelle sofort, dass bei einer Einfügung maximal zwei Rotationen vorkommen, und zwar bei Fall E4 nach Fall E3. Denn nach einer Rotation kommt kein neuer Iterationsschritt – die Rotationen befinden sich endrekursiv am Ende der letzten ausgeführten Iteration.
  , dann ist die Angabe x (s. Zusammenschau) auf „o“ für „außen“, sonst auf „i“ für „innen“ zu setzen.Die Diagramme zu den Fällen zeigen nur eine Kindesrichtung, und zwar ist bei der Operation Einfügen der Elterknoten 
Die kleinen nummerierten Dreiecke stellen (Rot-Schwarz-)Teilbäume dar. Diese Teilbäume haben alle dieselbe Schwarztiefe, die in der ersten Iteration 0 ist.
Der alte Problemknoten (in der linken Hälfte des Diagramms) hat eine blaue Kontur; und wenn die Operation nicht beendet ist, dann auch der neue (rechts).
Jeder Fall wird unter seiner Fallnummer erläutert und einschließlich Test (auf die ihn charakterisierende Bedingung) und Transformation durch ein Stück C-Code genau beschrieben.Einfügen Fall E1: Der Elter 
Nach dieser Bedingung gibt es kein Paar Elter→Knoten (mehr), das die Forderung !RR verletzt. Ferner ist nach Voraussetzung (Schleifeninvariante) die Anzahl der schwarzen Knoten auf allen Pfaden dieselbe.
   in schwarz stellt die Forderung !RR im ganzen Baum wieder her. Auf jedem Pfad erhöht sich die Anzahl der schwarzen Knoten um 1.
   durch einen weniger führen. Da jedoch in beiden Fällen rote Knoten den Unterschied ausmachen, ändert sich an der Anzahl der schwarzen Knoten nichts, womit die Forderung S#= erfüllt bleibt.
  , so ist in dem dadurch entstehenden Baum die Forderung !RR wieder erfüllt. Die Forderung S#= bleibt ebenfalls erfüllt, da alle Pfade, die durch einen dieser drei Knoten laufen, vorher durch 
Wie oben angemerkt, könnte eine rote Wurzel ohne Verletzung der Rot-Schwarz-Regeln auf schwarz umgefärbt werden – was den Test auf Bedingung_E2 und den Fall E2 überflüssig machen würde.
   aber zwei Kinder, dann nimmt man, ohne letztlich die Sortierreihenfolge zu stören, als effektiven Löschknoten seinen hinsichtlich Reihenfolge linken oder rechten Nachbarn (dieser kann kein rechtes resp. kein linkes Kind haben!) – natürlich, nachdem man vorher die Benutzerdaten ausgetauscht hat.
Die Löschung kann also durch die Entfernung eines Knotens mit maximal einem Kind durchgeführt werden, eines Knotens, der weiterhin mit 
Die nun folgenden Aktionen überprüfen, ob die Rot-Schwarz-Eigenschaften im Baum eingehalten sind und stellen sie wenn nötig wieder her.
Und da alle Pfade, die durch den roten Knoten verliefen, nach seiner Löschung durch einen roten Knoten weniger verlaufen, ändert sich an der Anzahl der schwarzen Knoten nichts, womit die Forderung S#= erfüllt bleibt.
   schwarz ist und ein Kind hat. Dieses ist dann zwangsläufig rot. Man färbt es schwarz und macht es an der Kindesrichtung d zum Kind von 
   aus dem Baum entfernt, und die Forderung !RR bleibt erfüllt. Ferner verlaufen nun alle Pfade, die durch den gelöschten schwarzen Knoten verliefen, durch sein nunmehr schwarzes Kind, wodurch Forderung S#= erfüllt bleibt.
  , enthalten die durch ihn führenden Pfade einen schwarzen Knoten weniger als vorher, somit einen weniger als die nicht durch 
Im nachfolgenden Beispielcode ist angenommen, dass eine vorausgehende Suchfunktion, die den zu löschenden Knotens 
   lokalisiert hat, den Stapel struct node* Parents[] von dessen Vorfahren gebildet und dessen Zeiger an die Löschfunktion übergeben hat. Wenn der Baum nicht leer ist, ist Parents[0] gleich dem Zeiger auf den Wurzelknoten.
Löschen: Erklärung der Symbole:Zu den Symbolen, die bei der Einfügeoperation erklärt wurden, kommt ein weiteres:
Das Symbol  (Dreieck mit hellgrauer Ellipse an der Spitze) steht für den Wurzelknoten eines Rot-Schwarz-Teilbaums derselben Schwarztiefe wie die anderen durch Dreiecke dargestellten Teilbäume.
In der ersten Iterationsstufe hat eine Zeigervariable X auf einen solchen „Knoten“ den Wert NULL. (Der Nullzeiger ist Indikator für das Fehlen eines Knotens an dieser Stelle.)
  , der Wurzel eines Teilbaums mit Schwarztiefe ≥ 1 ist.Löschen: Invariante der Schleife zur Überprüfung und Reparatur:
   enthalten einen schwarzen Knoten weniger.Löschen: Zusammenschau der FälleDie möglichen Farbkonstellationen lassen sich in sechs Fälle gruppieren, zu denen es Transformationen (enthaltend Rotation und/oder Umfärbung) gibt, die entweder auf der betrachteten Ebene oder über weitere Iterationsschritte auf höheren Ebenen zu einer Reparatur des Baumes führen.
die Konstellation nach Transformation und ggf. Zuweisung in der Spaltengruppe Ergebnisenthält. Eine Konstellation (5 Spalten) besteht aus den 5 Farben der 5 Knoten 
Eine Zelle ist leer gelassen, wenn es bei dem beschriebenen Fall auf die entsprechende Angabe nicht ankommt.
Die Konstellationen in der Gruppe Bedingung genügen der Schleifeninvariante, und ihre logische Summe schöpft diese zu 100 % aus.
Die Transformation, deren Fallnummer in der Spalte Fall → verlinkt ist, transformiert die Eingabe in eine Konstellation, die im Diagramm des Falles dargestellt ist. Steht ein Häkchen „✓“ in der Spalte → Test, dann reflektiert die Gruppe Ergebnis den Endstand, und die Löschoperation ist durch die Transformation abgeschlossen.
Andernfalls steht dort die Fallnummer derjenigen Bedingung, auf die die transformierte und neu zugewiesene Konstellation zu testen ist, wobei die entsprechende Zuweisung, angegeben für den Problemknoten 
Die Gruppe Ergebnis zeigt die Konstellation nach der Zuweisung, wobei Fragezeichen bei denjenigen Knoten stehen, auf deren Farbe es in den nächsten Abfragen ankommt.
Der Eintrag „L0“ kommt nur bei der Transformation_L1 vor und bedeutet ggf. einen neuen Iterationsschritt auf der um 1 höheren Ebene im Baum, beginnend mit dem Test auf die Bedingung_L0.
  . Gemäß § #Durchschnittliche und amortisierte Laufzeit ist der Rebalancierungsaufwand im Mittel sogar konstant.
Bei einem Eintrag in der Spalte Rotation ist eine Rotation an der Transformation beteiligt. Und die Tabelle zeigt, dass bei einer Löschung maximal drei Rotationen (von Fall L2 über L4 zu L5) erforderlich sind. Denn nach einer Rotation kommt kein neuer Iterationsschritt – die Rotationen befinden sich endrekursiv am Ende der letzten Iteration.
  .Die Diagramme bei den Fällen zeigen nur eine Kindesrichtung, und zwar ist bei der Operation Löschen der Problemknoten 
Der alte Problemknoten (in der linken Hälfte des Diagramms) hat eine blaue Kontur; und wenn die Operation nicht beendet ist, dann auch der neue (rechts).
Jeder Fall wird unter seiner Fallnummer erläutert und einschließlich Test (auf die ihn charakterisierende Bedingung) und Transformation durch ein Stück C-Code genau beschrieben.
   einen schwarzen Knoten hinzu und gleicht damit den fehlenden schwarzen Knoten auf diesen Pfaden aus.
   (s. Diagramm) so verändert, dass sie durch einen roten Knoten weniger und die Pfade durch den Knoten 
   vor der Transformation noch nicht schwarz war, so ist er nach der Transformation schwarz, und falls 
   führen. Da die beiden Knoten aber nur ihre Farben vertauscht haben, ändert sich an der Anzahl der schwarzen Knoten (Schwarztiefe) auf dem Pfad nichts.
   angenommen hat. Somit ändert sich die Anzahl der schwarzen Knoten eines solchen Pfades nicht.Da die Anzahl der schwarzen Knoten in den Pfaden, die durch 
Wie schon in der Einleitung ausgeführt, ist die besondere Eigenschaft von Rot-Schwarz-Bäumen, dass sie in logarithmischer Zeit – genauer in 
   als der Anzahl der Schlüssel – ein Element im Baum suchen, löschen oder einfügen können. Diese Operationen sind auf allen binären Suchbäumen von der Höhe 
   des Baumes abhängig. Je niedriger die Höhe des Baumes ist, desto schneller laufen die Operationen. Kann man nun beweisen, dass ein binärer Suchbaum mit 
  ) überschreitet, so hat man bewiesen, dass die oben genannten Operationen im schlechtesten Fall logarithmische Kosten haben, nämlich die genannten Kosten von 
   eine minimale Knotenzahl besitzt, muss er genau einen längsten Pfad enthalten, und dieser eine größtmögliche Anzahl roter Knoten, um eine möglichst große Baumhöhe mit möglichst kleiner Schwarztiefe zu erreichen. Seine Einfärbung hat also unten beim Blatt mit Rot zu beginnen, und sich in der Folge nach oben bis zur Wurzel mit Schwarz und Rot streng abwechselnd fortzusetzen. Außerhalb dieses die Baumhöhe definierenden Pfades hat er nur schwarze Knoten. Denn angenommen, es gäbe dort einen roten Knoten, dann beeinträchtigt das Entfernen desselben die Rot-Schwarz-Eigenschaften nicht, sofern einer von seinen zwei (schwarzen) Kindknoten an seine Stelle nachrückt und der andere gleichzeitig einschließlich seines Teilbaums entfernt wird. Alle Teilbäume außerhalb des längsten Pfades sind somit vollständige Binärbäume mit ausschließlich schwarzen Knoten.
    {\displaystyle 2^{\lfloor (1+1)/2\rfloor }\!+\!2^{\lfloor 1/2\rfloor }\!-\!2=2^{1}\!+\!2^{0}\!-\!2}
   sind die zwei Kindbäume der Wurzel von unterschiedlicher Höhe: der höhere enthält den die Höhe definierenden längsten Pfad und ist ein Minimalbaum der Höhe 
   Formen von Minimalbäumen, da die Position des längsten Pfades der Position eines externen Blattes des vollständigen Binärbaums der Höhe 
   entspricht und dadurch auch die Lage der Knoten außerhalb dieses Pfades bestimmt ist. (Die Abbildung zeigt die äußerste linke Position.)
    {\displaystyle m_{h}=3\cdot 2^{\tfrac {h-1}{2}}-2=3\cdot 2^{-{\tfrac {3}{2}}}\cdot 2^{\tfrac {h+2}{2}}-2>2\cdot 2^{\tfrac {h}{2}}-2,}
    {\displaystyle {\begin{matrix}&2\cdot 2^{\tfrac {h}{2}}-2&\leq &n\\\Longleftrightarrow &2\cdot 2^{\tfrac {h}{2}}&\leq &n+2\\\Longleftrightarrow &1+{\tfrac {h}{2}}&\leq &\log _{2}(n+2)\\\Longleftrightarrow &{\tfrac {h}{2}}&\leq &\log _{2}(n+2)-1\\\Longleftrightarrow &h&\leq &2\log _{2}(n+2)-2\\\end{matrix}}}
   hat und damit die Operationen suchen, einfügen und löschen in logarithmischer Zeit erledigen kann. Drückt man dieses Ergebnis in der O-Notation aus, so ergibt sich für die Kosten der oben genannten Operationen, dass sie alle in 
Der Rot-Schwarz-Baum bietet amortisiert konstante Rebalancierungskosten und damit auch im Mittel konstante.
Anwendungen von (binären) Suchbäumen, die neben Sequenzen von Einfügungen und Löschungen auch Suchoperationen enthalten, sind asymptotisch durch die logarithmische Laufzeit der letzteren dominiert.
Interessant ist der amortisiert konstante Modifikations-Aufwand jedoch, wenn der Suchbaum persistent gehalten werden soll, d. h. alle Versionen zugänglich bleiben sollen (s. a. en:Persistent data structure).
   die Gesamtzahl der Rot-Schwarz-Bäume, Folge A001137 in OEIS derer mit schwarzer Wurzel und Folge A001138 in OEIS derer mit roter Wurzel.
Beim Suchen und Traversieren ist wegen der identischen Verzweigungen der 3 Bäume alles Verhalten einschließlich Laufzeit gleich. Unterschiede gibt es aber bei den Einfügungen: Bei den rechten 2 Bäumen sind alle Einfügungen vom Typ Transformation_E2 und beim linken Baum alle vom Typ Transformation_E3 gefolgt von Transformation_E1.
Zwar wird in einem reinen Einfügeszenario von den 3 möglichen Bäumen mit 3 Knoten (Schlüsseln) nur der eine Baum mit schwarzer Wurzel und 2 roten Kindern (der linke in der Abbildung) gebildet. Bezieht man jedoch Löschungen mit ein, dann kommen die zwei anderen Rot-Schwarz-Bäume (rechts in der Abbildung) hinzu, und zwar der mit roter Wurzel über
und dies mit den oben beschriebenen Algorithmen für Einfügung und Löschung – jeweils bei geeignet gewählter Schlüsselfolge, die durch den Knoten mit blauer Kontur angegeben ist.
Die 4 kleinen Grafiken links und rechts zeigen, wie kleine Bausteine eines Rot-Schwarz-Baums (linke Hälften der Grafiken) mit einem (dicken) Knoten eines 2-3-4-Baums (rechte Hälften der Grafiken) zur Entsprechung gebracht werden können.
Man erzeugt aus einem Rot-Schwarz-Baum einen 2-3-4-Baum, indem man rote Kinder entsprechend ihrer Kindesrichtung links oder rechts als Datenelemente in den schwarzen Elterknoten hereinholt.
Umgekehrt kann man einen 2-3-4-Baum ganz einfach in einen Rot-Schwarz-Baum überführen: Aus einem Knoten mit 2 Datenelementen und 3 Kindzeigern (wie der Knoten [NIL,1,6] in der Abbildung) wird ein schwarzer Knoten (Datenelement) mit 1 Kindzeiger und einem roten Kindknoten (Datenelement), der noch 2 Kindzeiger enthält; aus einem Knoten mit 3 Datenelementen und 4 Kindzeigern (wie die Knoten [8,13,17] und [22,25,27] in der Abbildung) wird ein schwarzer Knoten (Datenelement) mit 2 roten Kindknoten (jeweils 1 Datenelement und 2 Kindzeiger).
Darüber hinaus gibt es Entsprechungen bei den Modifikationsoperationen (Einfügen, Löschen) zwischen Farbwechsel und Rotationen auf Seite der Rot-Schwarz-Bäume und den Aktionen Spalten (split) und Verschmelzen (fuse) bei den 2-3-4-Bäumen.
Im Gegensatz zu 2-3-4-Bäumen muss man bei Rot-Schwarz-Bäumen nicht den „Füllzustand“ (Speicherausnutzung, engl. fill factor) der Knoten beobachten und verwalten, weshalb letztere als sehr effiziente Art der Implementierung der 2-3-4-Bäume gelten.
Die Menge der AVL-Bäume ist eine echte Teilmenge in der Menge der Rot-Schwarz-Bäume. Denn jeder Binärbaum, der das AVL-Kriterium erfüllt, lässt sich in einer das Rot-Schwarz-Kriterium erfüllenden Weise einfärben.
Es gibt aber Rot-Schwarz-Bäume, die das AVL-Kriterium nicht erfüllen. Die nebenstehende Abbildung zeigt zum Beispiel einen Rot-Schwarz-Baum mit 6 Knoten und der externen Pfadlängensumme 21, während 20 die größte externe Pfadlängensumme bei AVL-Bäumen (und zugleich die kleinstmögliche für alle Binärbäume) dieser Größe ist. Konsequenterweise ist auch die Worst-Case-Höhe des AVL-Baums kleiner als die des Rot-Schwarz-Baums, und zwar um den Faktor (2 log2 Φ)−1 ≈ 0,720. Allgemein werden AVL-Bäume als besser balanciert und ihr Suchverhalten als günstiger angesehen.
Die Laufzeiten für alle angeführten Operationen unterscheiden sich im Mittel und im Worst Case asymptotisch nur um einen konstanten Faktor, gehören also derselben Komplexitätsklasse an. Der Rot-Schwarz-Baum bietet allerdings amortisiert konstante Einfüge- und Löschkosten (jeweils nur Rebalancierung – ohne Navigation). Beim AVL-Baum sind nur die Einfügekosten amortisiert, die Löschkosten immerhin im Mittel konstant.
Realistische Anwendungssituationen mit Performancedaten und -vergleichen – auch mit weiteren Suchalgorithmen und Spielarten der Datenstrukturen – finden sich bei Ben Pfaff. Seine Ergebnisse zeigen in 79 Messungen unter anderem die sehr große Ähnlichkeit von AVL-Bäumen (AVL) und Rot-Schwarz-Bäumen (RB) mit Laufzeitverhältnissen AVL⁄RB zwischen 0,677 und 1,077 bei einem Median von ≈0,947 und einem geometrischen Mittelwert von ≈0,910.
Der Speicherplatzbedarf ist praktisch identisch: 1 Bit für die Rot-Schwarz-Farbe gegenüber 2 Bits für den AVL-Balance-Faktor. Während die Balance-Faktoren eines AVL-Baums direkt von dessen Gestalt abhängen, sind bei Rot-Schwarz-Bäumen derselben Gestalt – außer bei den Minimalbäumen gerader Höhe – unterschiedliche Einfärbungen möglich (s. § #Anzahlen von Rot-Schwarz-Bäumen). Dabei wirken sich die Unterschiede der Einfärbungen nur auf die Modifikations- und nicht auf die Navigationsoperationen aus. Des Weiteren kann jede mögliche Gestalt eines AVL-Baums durch gezielte Einfügungen auch hergestellt werden. Bezogen auf die Baumform gilt dies auch für Rot-Schwarz-Bäume; es gibt aber Baumformen, bei denen durchaus regeltreue Einfärbungen in einem reinen Einfügeszenario nicht bewirkt werden können.
Eine Folge dieser etwas größeren Freiheitsgrade ist, dass im Rot-Schwarz-Baum die für die Einfügung oder Löschung erforderlichen Farbänderungen und Rotationen schon während des Suchvorgangs – also beim Abstieg – vorgenommen werden können. Diese „Top-Down-Strategie“ ist bspw. für nebenläufige und persistente Programmierung interessant.
So bleibt beim Einfügen der frisch eingefügte Knoten rot (das sind die Fälle 1 bis 5). Das bedeutet, dass eine zugehörige Suchfunktion im Abstieg den Baum an der betreffenden Stelle (in logarithmischer Zeit) so vorbereiten kann, dass das endgültige Einfügen unmittelbar bei einem schwarzen Elter in Form eines roten Knotens geschehen oder eben auch unterbleiben kann. Genauso kann beim Löschen eine (andere) Suchfunktion den Baum im Abstieg so vorbereiten, dass der zu löschende Knoten rot ist. In beiden Fällen bleibt der Baum sowohl beim Durchführen wie beim Unterlassen der Modifikation ein gültiger Rot-Schwarz-Baum, einer Modifikation, die beim Einfügen nur aus dem Setzen eines einzigen Zeigers besteht und beim Löschen nur geringfügig komplizierter ist. Demgegenüber gibt es beim AVL-Baum Baumformen, bei denen die Entscheidung betreffend den Vollzug der Modifikation nicht mit derart geringer Implikation offen gehalten werden kann.
Im Java Development Kit sind die Klassen TreeSet und TreeMap als Rot-Schwarz-Bäume implementiert. Sie stellen geordnete Mengen bzw. geordnete Dictionarys zur Verfügung.
Ben Pfaff: An Introduction to Binary Search Trees and Balanced Trees. Free Software Foundation, Boston 2004, ftp.gnu.org (PDF gzip; 1662 kB; abgerufen am 13. Januar 2019).
Ben Pfaff: Performance Analysis of BSTs in System Software. Stanford University, 2004, stanford.edu (PDF; 316 kB).
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein: Introduction to Algorithms. 2. Auflage. MIT Press, Cambridge (Massachusetts) 2001, ISBN 0-262-03293-7, S. 273–301. 
Robert Sedgewick: Algorithmen in C++. Addison-Wesley, 1992, ISBN 3-89319-462-2, S. 260–270 (englisch). 
Robert Sedgewick, Kevin Wayne: Algorithms Fourth Edition. Pearson Education, 2011, ISBN 978-0-321-57351-3, S. 432–447.
Andrew Binstock, Jon Rex: Practical Algorithms for Programmers. Addison-Wesley Professional, 1995, ISBN 0-201-63208-X.
Kurt Mehlhorn: Datenstrukturen und effiziente Algorithmen. Teubner Stuttgart 1988, ISBN 3-519-12255-3.
Kurt Mehlhorn, Peter Sanders: Algorithms and Data Structures. The Basic Toolbox. Springer, Berlin/Heidelberg 2008, ISBN 978-3-540-77977-3, doi:10.1007/978-3-540-77978-0. 
