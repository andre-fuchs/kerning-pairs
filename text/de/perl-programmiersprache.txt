Perl [pɝːl] ist eine freie, plattformunabhängige und interpretierte Programmiersprache (Skriptsprache), die mehrere Programmierparadigmen unterstützt.
Der Linguist Larry Wall entwarf sie 1987 als Synthese aus C, awk, den Unix-Befehlen und anderen Einflüssen. Ursprünglich als Werkzeug zur Verarbeitung und Manipulation von Textdateien insbesondere bei System- und Netzwerkadministration vorgesehen (zum Beispiel Auswertung von Logdateien), hat Perl auch bei der Entwicklung von Webanwendungen und in der Bioinformatik weite Verbreitung gefunden. Traditionell vertreten ist Perl auch in der Finanzwelt, vor allem bei der Verarbeitung von Datenströmen verschiedenartiger Nachrichtenquellen. Hauptziele sind eine schnelle Problemlösung und größtmögliche Freiheit für Programmierer. Die Bearbeitung von Texten mit Hilfe regulärer Ausdrücke sowie viele frei verfügbare Module, die an einem zentralen Ort (CPAN) gesammelt werden, sind Stärken der Sprache.
Larry Wall war als Administrator und Programmierer bei dem Unternehmen Unisys angestellt, wo er seit März 1987 daran beteiligt war, unter dem Namen blacker ein sicheres Netzwerk für die NSA zu entwickeln. Er erhielt mehrere Aufträge, Werkzeuge zur Überwachung und Fernwartung der entstehenden Software zu schaffen. Eine Hauptaufgabe war dabei, übersichtliche Berichte aus verstreuten Logdateien zu erzeugen. Da ihm die vorhandenen Sprachen und Werkzeuge dafür zu umständlich erschienen, entwickelte er mit Hilfe seines damaligen Teamkollegen Daniel Faigin und seines Schwagers Mark Biggar schrittweise eine eigene Sprache, um seine Aufgaben zu lösen.
Dabei griff er auch auf sein Wissen und seine Erfahrung als Linguist zurück und entwarf Perl nahe an den menschlichen Sprachgewohnheiten. Dies drückt sich in minimalen Voraussetzungen für Einsteiger, einer starken Kombinierbarkeit der Sprachelemente und einem reichen Wortschatz aus, der auch Befehle zulässt, deren Bedeutungen sich überschneiden. Wall sieht darin die Bedürfnisse eines Praktikers nach Freiheit und intuitivem Ausdruck verwirklicht.
Gemäß diesem praktischen Ansatz borgte sich Perl seinen Wortschatz und seine logischen Strukturen von den in den 1980er Jahren unter Unix verbreiteten Sprachen und Werkzeugen, was das Erlernen vereinfachte, aber auch die Unix-Philosophie umkehrte. Unix und seine Systembefehle waren kompiliert und meist in C geschrieben. Diese Befehle waren logische Einheiten und sollten genau eine Aufgabe beherrschen: „Do one thing and do it well“ („Mach genau eine Sache und mach sie gut“). Interpretierte Shell-Skripte kombinierten schnell und einfach die Befehle, die untereinander ihre Ergebnisse durch Pipes weiterreichen konnten. Perl verletzt diese Philosophie, indem es diese Befehle zum Bestandteil der Programmiersprache macht, also C und Shell vereint und die vorhandenen Befehle und Werkzeuge übergeht.
Dies wurde notwendig, weil Shell-Skripte für komplexe Aufgaben ungeeignet waren. Ihr Ablauf ist sehr einfach,
sie können Daten nur eingeschränkt zwischenspeichern und die Pipes sind Flaschenhälse beim Datenaustausch. Andererseits erlauben sie einen wesentlich kompakteren Programmierstil, da die Benutzung eines UNIX-Werkzeugs viele Zeilen C-Quelltext ersetzen kann.
Um die Vorteile beider Programmierarten nutzen zu können, schuf Wall eine Kombination aus C und Werkzeugen wie sed, awk, grep und sort. Er fügte Eigenschaften der Bourne Shell, in geringem Maße auch Elemente aus Pascal und BASIC, sowie eigene Ideen dazu. Diese Fusion ermöglichte kurze, mächtige Programme, die man schnell schreiben und jederzeit auch testen konnte, ohne sie kompilieren zu müssen, was die Entwicklung ebenfalls beschleunigte. Später wurden weitere Fähigkeiten von Sprachen wie Lisp, Smalltalk, Python oder Ruby „importiert“.
Der Name Perl bezieht sich auf ein Zitat aus dem Matthäus-Evangelium (Mt 13,46 ), in dem Jesus das Himmelreich mit dem Bild eines Händlers beschreibt, der seinen gesamten Besitz verkaufen will, um eine kostbare Perle zu erwerben. Noch vor der Veröffentlichung wurde der Name von „Pearl“ in „Perl“ geändert, da es bereits eine Programmiersprache namens PEARL gab. Allgemein verbreitet und von Larry Wall akzeptiert sind auch die Backronyme Practical Extraction and Report Language (zweckmäßige Extraktions- und Berichtssprache) und Pathologically Eclectic Rubbish Lister (krankhaft stilmischender Blödsinnsauflister). Die Schreibweise „Perl“ bezeichnet die Sprache, „perl“ dagegen das Programm, das diese Sprache interpretiert. Ferner legt die Perl-Gemeinde Wert darauf, dass nicht die Schreibweise „PERL“ verwendet wird, da es sich nun mal nicht um ein Akronym handelt.
Am 18. Dezember 1987 publizierte Larry Wall sein Programm im Usenet als Perl 1.0, das damals noch eine mächtigere Shell war, die gut mit Texten und Dateien umgehen, andere Programme steuern und gut lesbare Berichte ausgeben konnte. Bereits am 5. Juni im Jahr darauf erschien die Version 2.0 mit grunderneuerter und erweiterter Regex-Engine und einigen weiteren Verbesserungen. Am 18. Oktober 1989 folgte Perl 3, das mit binären Daten umgehen konnte und auch Netzwerkprogrammierung ermöglichte. Als neue Lizenz wurde die GPL gewählt.
Fast unverändert war es ab dem 21. März 1991 als Perl 4 erhältlich, jedoch nun wahlweise unter der GPL oder der von Larry Wall entwickelten Artistic License. Der eigentliche Grund für die neue Version war aber das gleichzeitig erschienene Kamelbuch, das als Referenz für den aktuellen, als Version 4 markierten Stand veröffentlicht wurde. Bis dahin waren die seit Perl 1 verfügbaren UNIX-man-pages die einzige verfügbare Dokumentation. Diese bieten zu jedem Thema eine fundierte und umfangreiche Abhandlung, aber keinen einfachen Einstieg für Perl-Anfänger.
Diese Lücke sollte das von Randal L. Schwartz, Larry Wall und Tom Christiansen verfasste Buch schließen. Es erschien im O’Reilly Verlag, der mit diesem und weiteren Titeln als renommierter Fachverlag für Programmierer bekannt wurde. Perl-Bücher von O’Reilly wurden die maßgeblichen Publikationen, was sich erst im neuen Jahrtausend etwas relativierte. Der Verlag betrieb auch unter der Internetadresse perl.com das meistbesuchte Online-Magazin für Perl-Programmierung und veranstaltet mit der TPC (The Perl Conference – heute OSCON) die größte Perl-Konferenz. O’Reilly profitierte von Perls wachsender Popularität, und im Gegenzug bezahlte Tim O’Reilly seinem Freund Larry Wall in den folgenden Jahren ein festes Gehalt, der sich so, ohne weitere Pflichten oder Vorgaben, der Weiterentwicklung der Sprache widmen konnte.
1993, als Perl die Version 4.036 erreichte, brach Larry Wall die Weiterentwicklung ab und entwickelte Perl 5 vollständig neu.
Perl 5.0 wurde am 18. Oktober 1994 veröffentlicht und war der bis dahin größte Fortschritt für die Sprache. Mit Plain Old Documentation konnte man nun formatierte Dokumentation in den Quelltext einfügen. Auch ließ sich die Sprache ab jetzt durch separate Module erweitern, was im folgenden Jahr zur Entstehung des CPAN führte. Dieses große Archiv frei erhältlicher Module ist heute selbst ein wichtiger Grund, Perl einzusetzen. Eine weitere, wichtige Neuerung war die Einführung von Referenzen, die erstmals eine einfache Erstellung zusammengesetzter Datenstrukturen erlaubte.
Mit Version 5 wurde es auch möglich, objektorientiert in Perl zu programmieren. Dabei wählte Larry Wall einen ungewöhnlichen Weg und leitete die dafür verwendete Syntax fast ausschließlich aus vorhandenen Sprachelementen ab (Packages, Package-Funktionen und Package-Variablen sowie den neuen Referenzen). Lediglich die Funktion bless() zum Anlegen eines Objektes und der Pfeil-Operator (->) zum Aufruf von Methoden kamen hinzu (der Pfeil-Operator ist eigentlich der Dereferenzierungsoperator, der aus einem Objekt, das aus einer Referenz auf die Klasse besteht, eine bestimmte Methode dereferenziert). Es entstand auch XS, eine Schnittstellenbeschreibungssprache, die es ermöglicht, Perl-Programme mit anderen Sprachen zu erweitern oder mit Perl-Programmen beliebige Software oder Hardware anzusprechen.
Seit der Veröffentlichung von Perl 5 beteiligte sich Larry Wall kaum noch an der Entwicklung der Sprache. Dies übernahmen freiwillig Perl-begeisterte Programmierer, die sogenannten Perl 5 Porters, die über die im Mai 1994 gegründete p5p-Mailingliste kommunizieren, aber auch zunehmend über einen eigenen Bug- und Request-Tracker (RT) über Fehlerbehebungen und neue Funktionen der Sprache entscheiden. Dabei übernimmt je Version ein sogenannter Pumpking die Leitung. Der Begriff Perl Porter entstammt der ursprünglichen Aufgabe der p5p-Liste, die Portierung von Perl auf andere Betriebssysteme zu koordinieren.
In den Jahren nach Version 5.0 wurde nicht nur Perl auf Macintosh und Windows portiert, sondern es verschob sich auch die Nummerierung der Versionen. Da sich an der Syntax nichts Wesentliches änderte, beließ man die 5 und erhöhte bei größeren Meilensteinen die erste Nachkommastelle, verwendete aber zusätzliche Nummern, um die Zwischenschritte zu zählen. Da Perl erst ab 5.6 mit Versionsnummern, die mehrere Kommata enthalten, umgehen konnte, wurden sie bis dahin z. B. Perl 5.001 oder Perl 5.001012 geschrieben. Ab 5.6 wurde auch das damals von Linux verwendete Versionsschema übernommen, bei dem gerade Nummern auf Fehlerfreiheit gepflegte Benutzerversionen hindeuten und ungerade auf Entwicklerversionen, in die neue Funktionen einfließen. Serien von Benutzerversionen (z. B. 5.8.x) werden untereinander binär kompatibel gehalten, was bedeutet, dass ein für Perl 5.8.7 kompiliertes Binärmodul auch mit 5.8.8, nicht jedoch zwingend mit 5.10 oder 5.6.1 funktioniert.
Diese Version brachte am 22. März 2000 einige neue experimentelle Fähigkeiten, die erst später ausreiften, wie Unicode und UTF-8, Threads und cloning. Auch 64-Bit-Prozessoren konnten nun genutzt werden. Sprachlich fügte diese von Gurusamy Sarathy geleitete Reihe vor allem lexikalisch globale Variablen (mit our) und eine Vektorschreibweise, die den Vergleich mehrstelliger Versionsnummern erlaubt, sowie die Spezialvariablen @- und @+, ein.
Mit der am 18. Juli 2002 von Nicholas Clark betreuten Reihe 5.8.x wurden vor allem die Probleme mit Unicode und den Threads behoben, aber auch die Ein-/Ausgabe (IO), Signale und die numerische Genauigkeit wurden entscheidend verbessert.
Neben verringertem Speicherverbrauch und einer erneuerten und nun auch austauschbaren Regex-Maschine brachte diese Version am 18. Dezember 2007 unter der Führung von Rafaël Garcia-Suarez vor allem Neuerungen, die dem Entwurf von Perl 6 entstammen und deren Gebrauch entweder einzeln oder kollektiv mit use feature ':5.10'; angemeldet werden muss oder kürzer use v5.10;. Dies gilt ab dieser Version für alle Funktionen, welche die Kompatibilität brechen könnten. Hierzu zählen say, given und when (analog zur switch-Anweisung in C), der smartmatch-Operator (~~), der defined or-Operator (//) und state-Variablen, welche die Erzeugung von Closures vereinfachen. Weitere nennenswerte Neuheiten umfassen den verlagerbaren Installationspfad, stapelbare Dateitestoperatoren, definierbare lexikalische Pragmas, optionale C3-Serialisierung der Objektvererbung und field hashes (für „inside out“-Objekte). Die Regex-Engine arbeitet nun iterativ statt rekursiv, was rekursive Ausdrücke ermöglicht. Komplexe Suchanfragen können nun auch verständlicher und weniger fehleranfällig durch named captures formuliert werden. Die Spezialvariablen $# und $* sowie die Interpreterschnittstellen perlcc und JPL wurden entfernt.
Im folgenden Jahr wurden die Quelle von Perforce auf Git umgestellt, was die Entwicklung und Herausgabe neuer Versionen wesentlich vereinfachte.
Diese von Jesse Vincent geleitete Version vom 12. April 2010 beinhaltet weit weniger große und sichtbare Veränderungen als 5.10. use v5.12; impliziert use strict; und use feature 'unicode_strings';, wodurch alle Befehle Strings als Unicode behandeln. Unter den technischen Verbesserungen sind besonders der aktualisierte Unicode (5.2), DTrace-Unterstützung und Sicherheit von Datumsangaben jenseits von 2038 hervorzuheben, suidperl wurde entfernt. Aus Perl 6 wurden der Ellipsen-Operator (yada-yada) und die Regex-Escape-Sequence \N übernommen, Modulversionen können jetzt von package und use verwaltet werden. Ebenfalls neu ist die Möglichkeit, eigene Schlüsselwörter durch Perlroutinen zu definieren. Dies ist allerdings als experimentell markiert und kann sich ändern. Für bessere Planbarkeit und Zusammenarbeit mit Distributionen erscheint ab 5. Dezember 2000 am 20. jedes Monats eine Entwicklerversion, alle 3 Monate eine kleine Benutzerversion und jedes Jahr eine große.
Ab 14. Mai 2011 erleichtern neue Modifikatoren und Steuerzeichen den Umgang mit Unicode, der auf den Stand 6.0 gebracht wurde. Built-ins für Listen und Hashes dereferenzieren automatisch (autoderef) und weite Teile der Dokumentation wurden überarbeitet oder neu geschrieben. Auch die Unterstützung von IPv6 wurde verbessert, sowie das Anbinden von Multithread-Bibliotheken erleichtert.
Die am 20. Mai 2012 herausgegebene Version beinhaltet zahlreiche syntaktische Glättungen, in Teilen erneuerte Dokumentation und den Wechsel zu Unicode 6.1. Die Leitung hatte Jesse Vincent und ab November 2011 Ricardo Signes. Durch einen neu eröffneten Spendentopf der Perl Foundation konnten zudem zwei langjährige Entwickler dazu verpflichtet werden, undankbare Aufgaben zum Abschluss zu führen und den Build-Prozess zu vereinfachen. Einzige grundlegend neue Funktionalität ist das mit use feature 'current_sub'; oder use v5.16; zuschaltbare Token __SUB__, eine Referenz auf die aktuelle Routine.
Die am 18. Mai 2013 erschienenen Funktionalitäten lexikalische Subroutinen (lexical_subs) und mit Mengenfunktionen erzeugte Zeichenklassen innerhalb regulärer Ausdrücke sind beide experimentell. Solche Funktionen, zu denen auch lexikalische Kontextvariablen (lexical_topic) und der Smartmatch-Operator gehören, erzeugen jetzt Warnhinweise, die mit no warnings 'experimental::funktionsname'; oder no warnings 'experimental'; abgeschaltet werden können. Die Hashes wurden konsequent randomisiert, um Programme besser gegen DoS-Attacken zu schützen.
Ebenfalls unter der Führung von Ricardo Signes kamen am 27. Mai 2014 die experimentellen Funktionalitäten der Subroutinen-Signaturen (signatures) und (postderef) ein alternativer Postfix-Syntax zum Dereferenzieren. Das mit 5.14 aufgenommene autoderef wurde als experimentell herabgestuft. Unicode 6.3 wird unterstützt und mit drand48 hat Perl nun einen eigenen, plattformunabhängig guten Zufallszahlengenerator. String- und Arraygrößen sind jetzt 64-Bit Werte.
Mit dem 1. Juni 2015 kamen der Doppeldiamantoperator (<<>>), bitweise Stringoperatoren (&. |. ^. ~.), ein 'strict'-Modus für reguläre Ausdrücke use re 'strict'; (re_strict), Unicode 7.0, Aliasing von Referenzen (refaliasing) und konstante Routinen (const_attr), die stets den mit der ersten Kompilierung ermittelten konstanten Wert liefern. Alle benannten Funktionalitäten (Name in Klammern) sind vorerst experimentell.
brachte am 9. Mai 2016 Beschleunigungen für Blöcke und numerische Operationen, sowie Unicode 8.0. Die Features postderef und postderef_qq wurden angenommen – autoderef und lexical_topic entfernt.
Unter Leitung von SawyerX wurde am 30. Mai 2017 die Regex-Option xx, einrückbare Here-Dokumente und Unicode 9.0 eingeführt. Das Feature lexical_subs wurde angenommen und '.' (das aktuelle Verzeichnis) wurde aus Sicherheitsgründen standardmäßig aus @INC (der Liste von Suchpfaden für Module) entfernt.
Erschien am 22. Juni 2018.  Nebst Unicode 10.0 erhielt Perl Aliase für besondere Regex-Gruppen mit sprechenden Namen in Lang- und Kurzfassung: zum Beispiel anstatt (?=...), nun auch (*positive_lookahead:...) oder (*pla:...). (*script_run: …) oder (*sr: …) wurde eingeführt, um einheitlich kodierten Text zu erkennen, was hilft Angriffen durch manipulierte Eingaben auszuweichen. Drei kritische Sicherheitslücken wurden geschlossen, mehrfache Derefernzierungen und Zusammenführungen von Zeichenketten beschleunigt, sowie die Operatoren (&. |. ^. ~.) sind nicht mehr experimentell. Außerdem wurde beschlossen, im Dokument perldeprecation darüber Buch zu führen, wann welche Funktion (mit 2 Versionen Vorwarnzeit) entfernt wird.
Auch wenn die neueste Benutzerversion 5.28 lautet, wird derzeit die Versionsreihe 5.26.x weiterhin gepflegt (aktuell ist 5.26.2). Die Versionen 5.24.4, 5.22.4, 5.20.3, 5.18.2, 5.16.3, 5.14.4, 5.12.5, 5.10.1 und 5.8.9 sind Schlusspunkte ihrer Reihe, sicherheitsrelevante Verbesserungen werden noch bis zu 3 Jahre nach Veröffentlichung einer Version nachgereicht. Bei Kernmodulen wird meist auf eine Kompatibilität bis zu 5.6 geachtet, bei wichtigen CPAN-Modulen meist 5.8.3. Derzeitige Änderungen finden im Entwicklerzweig 5.29 statt, der nicht für allgemeine Benutzung bestimmt ist. Die nächste Perlversion wird 5.30 und nicht Perl 6 sein. Perl 6 ist eine Schwestersprache, deren Interpreter und die umgebende Infrastruktur vollständig neu gestaltet worden sind.
Am 19. Juli 2000 auf der TPC 4 wurde Perl 6 als die Version der Perl-Gemeinschaft angekündigt. Nachdem Larry Wall 361 Vorschläge auswertete und thematisch sortierte, schrieb er je Thema einen Überblick seiner Vorstellungen (Apocalypse genannt), der nach Diskussionen in den Mailinglisten von Damian Conway zu einer detaillierten Exegese formuliert wurde. Darauf folgend wurde die Sprache in kleinerem Kreis weiterentwickelt, wobei die Impulse vor allem von den Implementatoren und Benutzern ausgehen und der aktuelle Stand dabei in wesentlich knapperen Synopsen festgehalten wurde. Diese wurden ab 2009 von einer regulären Dokumentation abgelöst und die Rolle der Spezifikation übernahm eine Testsuite, die auch der Überwachung des Entwicklungsstandes der einzelnen Implementationen dient.
Die Sprache wurde entrümpelt und mit neuen Fähigkeiten ausgestattet. Unter anderem wurde die Objektorientierung komplett neu gestaltet und funktionale Programmierelemente wie Hyperoperatoren und Junctions eingeführt. Makros lösen die Sourcefilter ab und die neu systematisierten und erweiterten regulären Ausdrücke lassen sich zu ableitbaren Grammatiken zusammenfassen. Sie erlauben es, den Compiler zu verändern oder um DSL zu erweitern, und werden mit dem smart match-Operator ~~ angewendet, der je nach Kontext verschiedene Arten von Daten, Datenstrukturen und auch Inhalte von Symboltabellen vergleichen kann. Der Bereich der asynchronen und parallelen Programmierung wird derzeit als letzter spezifiziert.
Als Interpreter für Perl 6 wurde ursprünglich (seit 2001) eine neue registerbasierte virtuelle Maschine namens Parrot entwickelt. Sie sollte viele Sprachen (auch gemischt) ausführen und ist für dynamische Sprachen wie Perl, Python oder Ruby optimiert. Parrot wurde von Dan Sugalski und Chip Salzenberg entworfen und später von Jonathan Leto und Patrick Michaud betreut, wobei letzterer für die Parrot Compiler Tools (PCT) zuständig war, einem Satz Werkzeuge für die Erstellung von Parsern und Compilern. Der auf Parrot und PCT basierende Perl 6-Compiler nennt sich Rakudo. Unter der Führung von Jonathan Worthington bekam Rakudo einen in NQP (sehr einfache Perlvariante) programmierten Unterbau, der es erlaubt, den Compiler auf die JVM (kleine Inkompatibilitäten) und .NET (geplant) zu portieren, sowie auf Moar, eine ausschließlich auf Rakudo ausgerichtete VM. Seit dem 29. Juli 2010 erscheint monatlich für „frühe Nutzer“ eine "Rakudo *"-Distribution mit Dokumentation und Bibliotheken sowie wahlweise Parrot oder (seit August 2014) Moar. Benutzenswerte Bibliotheken sind gelistet und werden mit zef installiert.
Audrey Tang leitete seit Anfang Februar 2005 die Entwicklung des alternativen Perl-6-Compilers namens Pugs in der Sprache Haskell. Mehrere Jahre war Pugs der vollständigste, aber auch langsamste Perl-6-Compiler und ermöglichte es als erster, zahlreiche Details der Sprache vorzuführen, zu testen und nachzubearbeiten. Die umfangreiche und in Perl 6 geschriebene Perl-6-Testsuite entstammt dem Pugs-Quellcode. Neben Ablegerprojekten wie elf und viv entstanden zahlreiche weitere Interpreter, Compiler- und Parser-Projekte, mit unterschiedlichen Schwerpunkten wie SMOP (Meta-OOP-runloop), Niecza (schneller Compiler für .NET), Sprixel, Perlito (compiliert u. a. zu im Browser ausführbarem JavaScript), Yapsi, welche teilweise wertvolle Erkenntnisse erbrachten, aber oft kaum direkten praktischen Nutzen. Einzig Rakudo, Perlito und gimme5 werden noch fortgesetzt. Letzteres übersetzt eine maschinell lesbare Definition der Perl 6-Syntax (STD genannt) nach Perl 5. Jede Software, welche diese Regeln einhält, darf sich offiziell Perl 6 nennen. Perl 6, welches am 25. Dezember 2015 offiziell als Version «Коледа» (auch englisch Christmas) veröffentlicht wurde, ist als „Schwestersprache“ ausgerufen, ohne jegliche Absicht Perl 5 mittelfristig zu ersetzen.
Da der Name „Perl 6“ teils als irreführend betrachtet wurde, hat Larry Wall dem Wunsch des Nutzers ZoffixZnet stattgegeben, als alternativen Namen der Sprache Raku bzw. Raku Perl 6 einzuführen.
Perl wurde für den praktischen Einsatz entwickelt und konzentriert sich daher auf schnelle und einfache Programmierbarkeit, Vollständigkeit und Anpassbarkeit. Diese Philosophie drückt sich in den folgenden Schlagworten oder Phrasen aus, die meist von Larry Wall stammen.
Das bekannteste und grundlegendste Perl-Motto ist „There is more than one way to do it“ (deutsch: „Es gibt mehr als einen Weg, etwas zu tun“), was meist zu TIMTOWTDI (selten TMTOWTDI) oder (mit englischer Kontraktion) „Tim To[a]dy“ verkürzt wird. Perl macht im Gegensatz zu Sprachen wie Python weniger Vorgaben und bietet absichtlich für jedes Problem mehrere Formulierungs- und Lösungsmöglichkeiten (Syntaktischer Zucker). Zum Beispiel kann man logische Operatoren als || und && (wie in C) oder (mit Bedeutungsnuancen) als or und and (wie in Pascal) schreiben; aber auch zahlreiche Befehle mit einem sich überschneidenden Funktionsumfang wie map und for erlauben verschiedene Formulierungen für den gleichen Sachverhalt. Einige Befehle wie der Diamant-Operator (<>) bieten verkürzte Schreibweisen für bereits vorhandene Funktionalität (hier wäre, mit leichten Unterschieden, <STDIN> äquivalent, was jedoch viel länger zu schreiben wäre). Diese Vielfalt wird auch im CPAN sichtbar, wo oft mehrere Module einen sehr ähnlichen Zweck erfüllen oder einen, der auch (wenn auch umständlicher) ad hoc implementiert werden könnte (Beispiel Getopt::Long).
Ein weiteres Schlagwort, das man auch als Erweiterung von TIMTOWTDI sehen kann, bezeichnet Perl als die erste postmoderne Programmiersprache. Damit ist gemeint, dass Perl verschiedene Paradigmen vereint und es dem Benutzer freisteht, strukturierte, objektorientierte, funktionale und imperative Sprachmerkmale zu kombinieren.
Der andere wichtige Merksatz ist Perl makes easy jobs easy and hard jobs possible, was zu deutsch bedeutet „Perl hält die einfachen Aufgaben einfach und macht (die Lösung) schwierige(r) Aufgaben möglich“. Dies beinhaltet zum ersten das Ziel, gängige Aufgaben möglichst mit kurzen „fertigen Lösungen“ zu vereinfachen. Zum Beispiel prüft -e dateiname die Existenz einer Datei. Einfache Aufgaben einfach zu belassen bedeutet für Perl aber auch, möglichst keine vorbereitenden Programmieranweisungen zu verlangen, wie das Anmelden von Variablen oder das Schreiben einer Klasse. Zweitens versucht Perl vollständig zu sein und für jedes Problem mindestens die Grundlagen bereitzustellen, die eine Lösung möglich machen. Das dritte Ziel, die ersten beiden Ziele nicht kollidieren zu lassen, gewinnt mit dem wachsenden Sprachumfang von Perl 6 immer mehr an Bedeutung, wo in Anlehnung an den Huffman-Code die Schreibweisen der am häufigsten verwendeten Befehle möglichst kurz gehalten sind, ohne mit der Logik der Schreibweise ähnlicher Befehle zu brechen.
In Perl gibt es Befehle, die verschiedene Bedeutungen haben, je nachdem in welchem Zusammenhang sie benutzt werden. Derart kontextsensitiv sind Datenstrukturen wie das Array. Wird es einem anderen Array zugewiesen, wird dessen Inhalt übergeben; ist der Empfänger ein einzelner Wert (Skalar), erhält dieser die Länge des Arrays.
Der Perl-Interpreter selbst ist ein in C geschriebenes Programm, das auf annähernd jedem Betriebssystem kompilierbar ist. Vorkompilierte Versionen auf selten verwendeten Systemen wie zum Beispiel BeOS oder OS/2 sind jedoch nicht immer auf dem neuesten Stand. Der Quellcode umfasst circa 50 MB und enthält auch Perl-Skripte, die die Funktion von Makefiles und der Test-Suite übernehmen. Typischerweise ist das kompilierte Programm circa 850 KB groß, was aber je nach Betriebssystem, verwendetem Compiler und Bibliotheken variieren kann.
Perl-Skripte werden in Textdateien mit beliebigem Zeilentrennzeichen gespeichert. Beim Start eines Skripts wird es vom Perl-Interpreter eingelesen, in einen Parse Tree umgewandelt, dieser zu Bytecode, welcher dann ausgeführt wird.
Strenggenommen ist Perl daher keine interpretierte Sprache, da ein Perl-Programm vor jeder Ausführung kompiliert wird. Das führt etwa dazu, dass – anders als bei rein interpretierten Sprachen – ein Programm mit Syntaxfehlern nicht startet.
Zu Beginn war Perl ein UNIX-Werkzeug, das besonders auf die Verarbeitung von Textdateien, Steuerung anderer Programme sowie zur Ausgabe von Berichten ausgelegt war. Dafür wird es bis heute, nicht nur von Systemadministratoren, auf allen verbreiteten Betriebssystemen eingesetzt. Dabei bekam Perl auch den Ruf einer glue language („Klebstoff-Sprache“), weil mit Hilfe von relativ schnell geschriebenen Perl-Skripten inkompatible Software verbunden werden kann. Bis heute gehört Perl auf allen POSIX-kompatiblen und Unix-ähnlichen Systemen zur Grundausstattung.
Mit der Verbreitung des World Wide Web wurde Perl zunehmend benutzt, um Webserver, Datenbanken und weitere Programme und Daten zu verbinden und die Ergebnisse in Form von HTML-Seiten auszugeben. Der Perl-Interpreter wird dabei über CGI oder FastCGI vom Webserver angesprochen oder ist direkt im Server eingebettet. (mod perl im Apache, ActiveState PerlEx im Microsoft IIS). Auch wenn für diese serverseitige Skript-Programmierung PHP mittlerweile populärer wurde, wird Perl weiterhin von vielen großen und kleinen Seiten und Internetdiensten wie Amazon.com, IMDb.com, slashdot.org, Movable Type, LiveJournal und XING verwendet. Da Perl-Skripte oft kaum erkennbar an vielen wichtigen Stellen arbeiten, wurde Perl auch scherzhaft als das Klebeband bezeichnet, welches das Internet zusammenhält. In Perl entstanden auch Frameworks wie Mason, Catalyst, Jifty, Mojolicious und Dancer, die eine sehr schnelle Entwicklung komplexer und leicht veränderbarer Webseiten erlauben. Auch Wiki-Software ist häufig in Perl geschrieben wie z. B. Socialtext, welches auf Mason basiert, Kwiki, TWiki, Foswiki, ProWiki oder UseMod. Auch verbreitete Ticket-Systeme mit Webschnittstelle wie Bugzilla oder RT sind in Perl geschrieben.
Jedoch sind WWW-Anwendungen weiterhin nur eines der vielen Einsatzgebiete von Perl. Wichtige Perl-Programme im E-Mail-Bereich sind SpamAssassin (Spam-Filter), PopFile und open webmail. Zur Systemverwaltung wird Perl zum Beispiel in debconf, einem Teil der Paketverwaltung des Betriebssystems Debian, benutzt.
Weitere Hauptanwendungsfelder sind das Data-Munging und die Bioinformatik, wo Perl seit etwa 1995 die am häufigsten verwendete Sprache war und immer noch bedeutend ist. Gründe hierfür sind wieder die Fähigkeit, Informationen in Textform zu verarbeiten, und die Flexibilität und Offenheit der Sprache, die es der internationalen Forschergemeinde erlauben, trotz unterschiedlicher Standards der Institute zusammenzuarbeiten. BioPerl ist hier die wichtigste Sammlung frei erhältlicher Werkzeuge, die sich vor allem auf das Gebiet der Genomsequenzenanalyse konzentriert. Beim Human Genome Project spielte Perl eine wichtige Rolle.
Auch Desktop-Anwendungen und Spiele wie Frozen Bubble können in Perl geschrieben werden. Die heutigen Computer sind schnell genug, diese Programme flüssig auszuführen.
Bereiche, in denen Skriptsprachen wie Perl nicht sinnvoll eingesetzt werden können, sind zum einen Anwendungen mit hohen Anforderungen an Hardware-Nähe oder Geschwindigkeit wie zum Beispiel Treiber oder Codecs. Zum anderen sollten sie nicht in stark sicherheitskritischen Bereichen (z. B. Flugzeugsteuerung) Verwendung finden, da aufgrund der laxen Syntaxprüfung (z. B. fehlendes/sehr schwaches Typsystem) viele Fehler erst zur Laufzeit auftreten und eine Verifizierung im Allgemeinen nicht möglich ist.
Für Aufgaben, die mit Perl nur schwierig oder langsam lösbar sind, bietet Perl mit dem Modul Inline eine Schnittstelle an, über die Programmteile in anderen Sprachen in ein Perl-Programm eingebunden werden können. Unterstützte Sprachen sind u. a. C, C++, Assembler, Java, Python, Ruby, Fortran und Octave.Anwendungsgebiete sind z. B.:
zusammenführen von Anwendungen in unterschiedlichen Sprachen („Glue-Funktion“ von Perl).Die Anwendung von Inline ist relativ einfach und gut dokumentiert. Bei kompilierten Programmteilen führt Inline mittels MD5-Kennung Buch über den Versionsstand, wodurch Mehrfachcompilierung des gleichen Codes vermieden wird.
Bei Inline erfordert die Übergabe der Parameter und Rückgabe der Ergebnisse einigen Aufwand. Bei kurzen Berechnungen überwiegt dieser Aufwand den Gewinn an Geschwindigkeit. Wird zum Beispiel die Mandelbrot-Menge berechnet, indem die Formel 
   über Inline als C-Funktion berechnet, die Iteration aber in Perl belassen, verlangsamt sich die Programmausführung gegenüber einer reinen Perl-Implementierung. Wird hingegen auch die Iterationsschleife in C ausgelagert, steigert sich die Performance signifikant.
Als Maskottchen von Perl dient ein Dromedar. Es zierte erstmals den Umschlag des auch als Kamelbuch bekannten Referenzwerkes Programming Perl. Sein Verleger (Tim O’Reilly) sagte in einem Interview scherzhaft als Begründung: Perl ist hässlich und kommt über lange Strecken ohne Wasser aus. Das Dromedar ist auf dem Programming Republic of Perl Emblem zu sehen, das oft als offizielles Perl-Logo angesehen wird und dessen nichtkommerziellen Gebrauch O’Reilly gestattet. Andere im Zusammenhang mit Perl benutzte Logos sind neben Perlen die aufgeschnittene Zwiebel (Erkennungszeichen der Perl Foundation) und der Komodowaran, der die weit verbreitete Perl-Distribution ActivePerl von ActiveState schmückt.
Perl erlaubt bedingt formatfreien Quellcode. Das bedeutet, dass Einrückungen und zusätzliche Leerzeichen syntaktisch unerheblich sind und auch Zeilenumbrüche nach Belieben eingefügt werden können. Dafür müssen Befehle eines Blocks mit Semikolon getrennt werden. Einige Sprachelemente wie Formate, heredocs und gewöhnliche reguläre Ausdrücke sind nicht formatfrei.
Charakteristisch für Perl ist, dass Variablen durch ein Präfix (auch Sigil genannt) gekennzeichnet werden, das ihren Datentyp anzeigt. Hier einige Beispiele:
* für Typeglobs: *allDatei-Handles, Verzeichnis-Handles und Formate besitzen kein Präfix, sind aber ebenfalls eigenständige Datentypen. Jeder Datentyp hat in Perl seinen eigenen Namensraum.
Skalare sind typlose Variablen für einzelne Werte; es können Strings, Zahlen (Ganz/Gleitkomma) oder Referenzen auf andere Daten oder Funktionen in ihnen gespeichert sein. Strings und Zahlen werden bei Bedarf automatisch und transparent ineinander umgewandelt, eine große Besonderheit von Perl.
Arrays fassen mehrere Skalare unter einem Variablennamen zusammen. Arrayeinträge haben einen Index. Die Zählung beginnt bei 0, wenn nichts anderes definiert wurde.
Hashes fassen ebenfalls Skalare zusammen, allerdings werden hier Einzelwerte (Values) nicht über numerische Indizes, sondern mit Hilfe zugehöriger Keys (Schlüssel) eindeutig identifiziert und angesprochen. Als Schlüssel kann man eine beliebige Zeichenkette benutzen, oder auch alles, was sich in eine Zeichenkette umwandeln lässt.Hashes und Arrays lassen sich einander zuweisen, wobei Hashes als Listen von Key/Value-Paaren betrachtet werden. Daten verschiedenen Typs lassen sich mittels Referenzen beliebig zu neuen Datenstrukturen kombinieren, beispielsweise sind Hashes denkbar, die neben (Referenzen auf) Arrays auch einzelne Skalare enthalten.
Package-Variablen werden automatisch erstellt, sobald sie das erste Mal verwendet werden. Weitaus häufiger im modernen Sprachgebrauch kommen gültigkeitsbeschränkte Variablen zum Einsatz. Diese müssen mittels my deklariert werden. our macht eine Variable im gesamten Programm verfügbar. undef variable gibt die angegebene Variable wieder frei.
if funktioniert wie aus C bekannt; unless (<Bedingung>), eine Besonderheit von Perl, ist eine Schreibweise für if (!(<Bedingung>)). Eine Case- oder Switch-Anweisung (given when) gibt es erst ab Perl 5.10, vorher musste man diese Struktur mit if … elsif … else nachbilden. Jedoch setzt given die Kontextvariable ($_) wie for und when wendet smartmatch (~~) darauf an, was dieses Konstrukt ungleich vielfältiger einsetzbar macht als traditionelle Case-Befehle. Das optionale default entspricht hier einem else. Die optimierten logischen Operatoren erlauben auch eine bedingte Ausführung. Bei or (bzw. ||) wird der zweite Ausdruck ausgeführt, wenn das Ergebnis des ersten kein wahrer Wert ist, and (bzw. &&) funktioniert analog.
Wie in C iterieren while und for (in der an C angelehnten Variante), solange die Bedingung wahr ist, until, bis sie wahr ist, und foreach iteriert über eine Liste. In Perl 5 sind for und foreach austauschbar.
last verlässt sofort die Schleife, redo wiederholt die derzeitige Iteration, und next springt zum continue-Block, bevor es dann mit der nächsten Iteration fortfährt. Diese Befehle können von einem Label-Bezeichner gefolgt sein, der bei geschachtelten Strukturen bestimmt, auf welche Schleife sich der Befehl bezieht.
Die oberhalb aufgezählten Kontrollstrukturen beziehen sich auf einen Block mit mehreren Anweisungen. Bei einzelnen Anweisungen kann man auch die verkürzte, nachgestellte Schreibweise wählen, die auch den (englischsprachigen) Lesern das Verständnis durch natürlichsprachige Formulierung erleichtert.
Seit seinen Anfängen waren reguläre Ausdrücke (Regex) ein besonderes Merkmal von Perl, da ähnliche Fähigkeiten bis dahin meist nur spezialisierte Sprachen wie Snobol und awk hatten. Durch die große Verbreitung setzte Perl einen inoffiziellen Standard, der durch die von Perl unabhängige und auch teilweise abweichende Bibliothek PCRE aufgegriffen wurde, die heute von mehreren bedeutenden Sprachen und Projekten verwendet wird.
Ab Version 5.0 hat Perl seine Regex-Fähigkeiten um viele Funktionen, wie z. B. Rückwärtsreferenzen, erweitert. Auch lassen sich reguläre Ausdrücke in Perl wesentlich direkter – als z. B. in Java – mit dem =~-Operator verwenden, da sie Kernbestandteil der Sprache sind und nicht eine zuschaltbare Bibliothek. Der eigentliche reguläre Ausdruck wird mit Schrägstrichen als Begrenzungszeichen notiert. Weil Schrägstriche häufig auch innerhalb regulärer Ausdrücke vorkommen können, dürfen auch viele andere Zeichen zur Begrenzung verwendet werden. Das verbessert die Lesbarkeit, weil man so Zeichen wählen kann, die sich vom Inhalt des regulären Ausdrucks abheben.
Perl kennt zwei Befehle für reguläre Ausdrücke, deren Verhalten mit vielen nachgestellten Optionen verändert werden kann.
Der m-Befehl steht für match, was Übereinstimmung bedeutet. Das m kann weggelassen werden, wenn man die Standardbegrenzungszeichen für reguläre Ausdrücke, nämlich Schrägstriche, verwendet. Der folgende Ausdruck durchsucht den Inhalt der Variable $var und liefert einen Array von Zeichenketten, auf die der Suchausdruck passt. Mit aktivierter g-Option liefert die Suche im Listenkontext alle Funde, deaktiviert alle erkannten Subausdrücke. Im Skalarkontext liefert der Ausdruck einen positiven Wert wenn der Suchausdruck gefunden wurde, mit c-Option die Anzahl der Funde. i lässt Groß- und Kleinschreibung ignorieren, o Variablen nur einmal interpolieren, m den String als mehrzeilig und s als einzeilig betrachten. Die x-Option ermöglicht es, den Suchausdruck der besseren Lesbarkeit wegen über mehrere Zeilen zu verteilen und ihn mit Kommentaren zu versehen.
Der s-Befehl steht für substitute, was ersetzen bedeutet. Er ersetzt den Teil des gegebenen Textes, auf den der Suchausdruck passt mit dem Ersatzausdruck.
Nach erfolgreicher Verwendung eines regulären Ausdruckes stehen folgende Sondervariablen zur Verfügung:
@+ – dazugehörige End-OffsetsDer oft in einem Atemzug mit m// und s/// beschriebene Operator tr/// hat mit ihnen nur die Schreibweise gemein. Er lehnt sich an den UNIX-Befehl tr an, der dem Ersetzen einzelner Zeichen dient. Synonym kann statt tr auch y geschrieben werden.
Neben diesen beiden kann auch der Befehl split erwähnt werden, der eine Zeichenfolge aufteilt anhand eines Trennzeichens, das auch ein regulärer Ausdruck sein darf.
qx – quote auszuführende externe AnwendungAlternatives Quoting und Variableninterpolation führen zu besonders gut lesbarem Code. Ein Beispiel zur Verdeutlichung:
Interpolation von Variablen im String machen das Ergebnis jetzt erkennbar. Escapes \ stören noch den Textfluss.
Austausch des Quotingzeichens macht Escapes überflüssig. Der Code ist nun optimal. qq leitet das Quoting von Variablen im String ein. Das beliebige Zeichen danach ist das Quotingzeichen für diesen String.
Häufigster Kritikpunkt an Perl ist seine mangelnde Lesbarkeit. Jedes nichttriviale Programm werde viel öfter gelesen als geschrieben. Tatsächlich bietet Perl überdurchschnittlich viele Freiheiten, die zu unleserlichem Code führen können (siehe Disziplinen). Andererseits ermöglicht die gleiche Freiheit es auch, nahe an der logischen Struktur des Problems oder dem menschlichen Verständnis zu programmieren. Die von Perl-Programmierern geschätzte Freiheit, persönlichen Vorlieben nachzugehen, muss bei Projekten, die von mehreren Programmierern oder über längere Zeiträume entwickelt werden, durch selbst auferlegte Regeln eingeschränkt werden, um spätere Probleme zu vermeiden. Dies erfordert zusätzlichen Kommunikationsaufwand oder die Verwendung von Software wie Perl::Critic.
Einige Teile der Syntax, wie die Objektorientierung und Signaturen, sind zwar einfach und sehr mächtig, werden aber häufig gegenüber vergleichbaren Sprachen wie Python oder Ruby als veraltet wahrgenommen und fordern bei standardisierten Herangehensweisen, besonders von Perl-Anfängern, zusätzliche Tipp- und Denkarbeit. Diese Probleme sollen in Perl 6 behoben werden oder können mit zusätzlichen, für Perl 5 erhältlichen Modulen umgangen werden. So gibt es mit Moose ein sehr modernes und umfangreiches Objektsystem, das sich stark an das von Perl 6 anlehnt. Moose gilt in der Zwischenzeit als De-facto-Standard für objektorientierte Programmierung mit Perl. Signaturen wurden mit 5.20 eingeführt, sind aber immer noch als experimentell eingestuft.
Weiterhin wurde Perl vorgeworfen, es verletze die UNIX-Philosophie. Siehe dazu den Abschnitt Entstehung.
Zum 30. Geburtstag von Perl hieß es im Dezember 2017 in der iX, die Sprache sei gegenüber dem Erfolg von Java, PHP, Ruby und Python zurückgefallen und könne diesen Rückstand mittlerweile nicht mehr aufholen. Perls Ruf sei „ruiniert“. Es gelte derzeit leider als „‚Write once, never read again‘-Sprache, gefüttert durch jahrelange ‚Obfuscated ist cool‘-Kultur und durch die Propagierung der schlimmsten Seiten von Perl.“ Perl sei „heute eine Nischensprache, verfolgt von Liebhabern in ihrer Freizeit.“Starke Kritik wird auch gegen Perl 6 erhoben, das zu hoch gesteckte Ziele habe und nach vielen Jahren noch keine sichtbaren Ergebnisse bringe, stattdessen die Zukunft von Perl (5) lähme. Perl 6 war von Anfang an als Langzeitprojekt ausgerufen, das ausschließlich auf nicht immer planbarer Freiwilligenarbeit und kaum finanzieller Unterstützung beruht. Seine konkreten Ziele zeichneten sich erst im Verlauf der Entwicklung ab, und es gab eindeutige Probleme bei der Kommunikation und der Außendarstellung. Allerdings stammen seit Perl 5.10 wesentliche Neuerungen aus Perl 6.
Wie auch bei anderen Projekten freier Software gibt es zwischen vielen Entwicklern und Benutzern der Sprache besondere soziale Bindungen, und es bildete sich eine eigene Kultur daraus. Die Perl-Kultur ist von Offenheit, Gastlichkeit und Hilfsbereitschaft, aber auch von Individualismus, Spieltrieb und Humor geprägt. Anfangs war sicher Larry Wall hierfür ein Vorbild, da er durch andere Projekte wie rn oder patch bereits bei der Veröffentlichung von Perl eine prominente Position in UNIX-Entwicklerkreisen hatte, doch mittlerweile zählen auch Randal L. Schwartz, Damian Conway, Audrey Tang, Brian Ingerson und Adam Kennedy zu den Leitfiguren, die durch ihre Arbeiten innerhalb der „Szene“ große Beachtung finden. Im Gegensatz zu kommerziellen Programmiersprachen lassen sich fast alle Aktivitäten auf persönliche Motivationen zurückführen. Dementsprechend ist die Perl Foundation eine reine Freiwilligen-Organisation, die sich als Angelpunkt einer sich selbst verwaltenden Gemeinschaft versteht und die gespendeten Gelder für einflussreiche Projekte und Personen, Organisation von Entwicklerkonferenzen und den Betrieb der wichtigsten Perl betreffenden Webseiten verwendet.
Lokale Benutzergruppen, die meist ein oder zweimal im Monat zu zwanglosen Treffen einladen, bei denen auch Vorträge gehalten werden können, nennen sich Perl Mongers und sind in über 200 größeren Städten auf der ganzen Welt zu finden. Größer, wesentlich straffer organisiert und meist landesbezogen sind die jährlichen Workshops, von denen der gut etablierte Deutsche Perl-Workshop der erste war. Workshops wollen ambitionierte Entwickler in einem möglichst erschwinglichen Rahmen lokal zusammenführen. Ein ähnliches Ziel haben die größeren Yet Another Perl Conferences (YAPC), die für die Regionen Nordamerika, Brasilien, Europa, Asien, Russland und Israel abgehalten werden. Am größten, allerdings auch am teuersten ist die von O’Reilly in den USA ausgerichtete The Perl Conference (TPC), die mittlerweile Teil der OSCON ist.
Seit etwa 2005 werden für engagierte Beitragende auch Hackathons abgehalten, meist zu den Themen Qualitätssicherung und Perl 6.
Viele Spracheigenschaften von Perl laden dazu ein, Programmcode kreativ zu gestalten. Dies hat zu verschiedenen intellektuellen, teils humorvollen, teils skurrilen Wettbewerben und Traditionen um die Programmiersprache Perl geführt.
Golf ist eine Sportart für Programmierer, bei der das kürzeste Programm (in ASCII-Zeichen), das eine gestellte Aufgabe vollständig erfüllt, gewinnt. Da Perl viele, teils trickreiche Kürzel und Abkürzungen gängiger Techniken kennt, ist dies eine besonders populäre Disziplin unter Perl-Programmierern.
Da Perl viele Elemente der englischen Sprache beinhaltet, gibt es regelrechte Wettbewerbe, in welchen die besten Beispiele für Perl-Poesie prämiert werden. Neben der freien Form, die lediglich Perl zum Inhalt hat, wird hier versucht, Gedichte zu schreiben, die vom Interpreter ohne Warnungen und Fehlermeldungen ausgeführt werden. Daneben gibt es auch noch einen Perl-Haiku-Wettbewerb, der dieser japanischen Gedichtform gewidmet ist.
Sehr berühmt und berüchtigt ist auch die Disziplin obfuscation (Verschleierung), für die es auch einen jährlichen Wettbewerb (den „Obfuscated Perl Contest“) gibt, der am ehesten mit dem International Obfuscated C Code Contest vergleichbar ist, den Larry Wall selbst zweimal gewann. Hier wird danach gestrebt, auf ungewöhnliche und kreative Art und Weise die Funktion eines Programms zu verschleiern. Dies ist in Perl besonders leicht, da es für fast alles Kürzel gibt, die Sprache selbst sehr dynamisch ist und viele Dinge abhängig vom Kontext automatisch geschehen, was auch oft als „Perl-Magie“ bezeichnet wird. Ein Beispiel von Mark Jason Dominus, das 2000 beim 5. Annual Obfuscated Perl Contest den zweiten Preis gewann (dieses Programm gibt den Text „Just another Perl / Unix hacker“ aus):@P=split//,".URRUU\c8R";@d=split//,"\nrekcah xinU / lreP rehtona tsuJ";sub p{
Eine Art Unterkategorie von obfuscation ist die von Randal L. Schwartz öffentlich begonnene Disziplin JAPH. Das sind Signaturen, die kleine Perl-Programme enthalten, welche meist nur den Namen des Autors oder eine Botschaft auf eine möglichst nicht nachvollziehbare Art ausgeben. Die Buchstaben JAPH sind die Anfangsbuchstaben von Schwartz’ Signatur Just Another Perl Hacker.
Das Perl-Modul Lingua::Romana::Perligata von Damian Conway ist wohl eines der skurrilsten Module schlechthin: Es ermöglicht dem Benutzer, Perl komplett in Latein zu schreiben. Wie in der lateinischen Sprache ist die Satzstellung (weitgehend) irrelevant für die Bedeutung eines Ausdrucks, stattdessen werden die Bezüge zwischen einzelnen Wörtern durch ihre Flexion hergestellt. Von Variablen bis Referenzen und mehrdimensionalen Arrays ist alles in dieser neuen Sprachdefinition vorhanden. Nahezu alle Sonderzeichen wurden aus der Sprache entfernt, Variablen gleichen Namens, aber unterschiedlicher Struktur (Beispielsweise $next und @next) werden dekliniert, um die entsprechende Variable zu adressieren. Etwas Beispielcode:insertum stringo unum tum duo excerpemento da.
Aus ähnlichem Antrieb entstanden „Sprach-Module“ für Klingonisch, Borg oder Leetspeak. Solche Module sind ein gutes Beispiel für den Zeitaufwand, den viele Leute Perl widmen; Perl kann man in diesem Sinne durchaus als Hobby bezeichnen.
Brian Ingerson legte mit seinem bekannten Modul namens Acme, das unmittelbar nichts weiter tut, als dem Benutzer zu bescheinigen, sein Programm habe den Höchstgrad an Perfektion erreicht, einen Grundstein für eine CPAN-Kategorie von Modulen, die keinen produktiven Nutzen haben, sogar oft bewusst kontraproduktiv sind oder eine Funktion vorgeben, die unmöglich so erreicht werden kann und eher als Witz zu verstehen ist. Dieses Spiel mit skurrilen Ideen umfasst beeindruckende ASCII-Art, Module, die den Quellcode unsichtbar machen (Acme::Bleach) oder sonstig humorvoll manipulieren, indem sie ihn zum Beispiel mit typischen Sprachfehlern des Präsidenten Bush versehen oder Methoden zufällig löschen, was die Anwesenheit einer diebischen Elster simulieren soll.
Es gibt viele bekannte Mottos und Zitate, die sich mit Perl selbst oder den Möglichkeiten der Sprache beschäftigen; hier einige Kostproben:
“Perl: the Swiss Army Chainsaw of Programming Languages.”(Perl: Die Schweizer Armee-Kettensäge der Programmiersprachen. Anspielung auf die Vielseitigkeit von Schweizer Taschenmessern.)
“Perl is the only language that looks the same before and after RSA encryption.” (Keith Bostic)(Perl ist die einzige Sprache, die vor und nach einer RSA-Verschlüsselung gleich aussieht.)
“… we often joke that a camel is a horse designed by a committee, but if you think about it, the camel is pretty well adapted for life in the desert. The camel has evolved to be relatively self-sufficient. On the other hand, the camel has not evolved to smell good. Neither has Perl.” (Larry Wall: über das Kamel als Perl-Maskottchen)(… wir witzeln oft, dass ein Kamel ein Pferd ist, das von einem Komitee entworfen wurde. Aber wenn man darüber nachdenkt, ist das Kamel ziemlich gut an das Leben in der Wüste angepasst. Das Kamel hat sich dahin entwickelt, autark zu sein. Andererseits hat es sich nicht dazu entwickelt, gut zu riechen. Perl auch nicht.)
“The very fact that it’s possible to write messy programs in Perl is also what makes it possible to write programs that are cleaner in Perl than they could ever be in a language that attempts to enforce cleanliness” (Larry Wall: Linux World, 1999)(Genau die Tatsache, dass es möglich ist, unsaubere Programme in Perl zu schreiben, ermöglicht es, Programme zu schreiben, die sauberer sind, als in Sprachen, die versuchen, Sauberkeit zu erzwingen.)
“Perl: Write once – never understand again”(Perl: Einmal schreiben – nie wieder verstehen. Eine Anspielung auf das “Write once – run everywhere”-Mantra z. B. von Java)
Im Jahr 2004 erreichte Perl beim 7. Wettbewerb des International Conference on Functional Programming Contest eine Platzierung in der Lightning Division und gewann 2007 den zweiten Platz.
Tom Christiansen, brian d foy, Larry Wall: Programming Perl. 4. Auflage. O’Reilly, Sebastopol CA, 2012, ISBN 978-0-596-00492-7
Randal L. Schwartz, brian d foy, Tom Phoenix: Learning Peal. 7. Auflage. O’Reilly, Sebastopol CA, 2017, ISBN 978-1-4919-5432-4.
Randal L. Schwartz, brian d foy, Tom Phoenix: Intermediate Perl. 2. Auflage. O’Reilly, Sebastopol, CA, 2012, ISBN 978-1-4493-9309-0.
Joseph N. Hall, brian d foy, Joshua A. McAdams: Effective Perl Programming. 2. Auflage. Addison-Wesley, Boston MA, 2010, ISBN 978-0-321-49694-2.
chromatic: Modern Perl, Onyx Neon Press 2011, ISBN 0-9779201-7-8. (aktuellere Referenz, als Ebook frei erhältlich)
Johan Vromans: Perl Pocket Reference. 5. Auflage. O’Reilly, Sebastopol CA, 2011, ISBN 978-1-4493-0370-9
Jon Orwant (Hrsg.): Games, Diversions & Perl Culture. O’Reilly, Sebastopol CA, 2010, ISBN 978-0-596-00312-8.
Mark Jason Dominus: Higher-Order Perl. Morgan Kaufmann, 2005, ISBN 1-55860-701-3 (Funktionale Programmierung in Perl)
