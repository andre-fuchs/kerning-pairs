Das Spiel besteht aus drei gleich großen Stäben A, B und C, auf die mehrere gelochte Scheiben gelegt werden, alle verschieden groß. Zu Beginn liegen alle Scheiben auf Stab A, der Größe nach geordnet, mit der größten Scheibe unten und der kleinsten oben. Ziel des Spiels ist es, den kompletten Scheiben-Stapel von A nach C zu versetzen.
Bei jedem Zug darf die oberste Scheibe eines beliebigen Stabes unter der Voraussetzung, dass sich dort nicht schon eine kleinere Scheibe befindet, auf einen der beiden anderen Stäbe gelegt werden. Folglich sind zu jedem Zeitpunkt des Spieles die Scheiben auf jedem Feld der Größe nach geordnet.
Vermutlich wurde das Spiel 1883 vom französischen Mathematiker Édouard Lucas erfunden – deshalb auch manchmal Lucas-Türme (engl. Lucas Tower) genannt. Er dachte sich dazu die Geschichte aus, dass indische Mönche im großen Tempel zu Benares, im Mittelpunkt der Welt, einen Turm aus 64 goldenen Scheiben versetzen müssten, und wenn ihnen das gelungen sei, wäre das Ende der Welt gekommen.
Das Spiel kann mit einer beliebigen Anzahl von Scheiben gespielt werden. Zur Erläuterung werden die Scheiben von der kleinsten bis zur größten mit S1 bis Sn bezeichnet, wobei n die Anzahl der Scheiben ist. Die Angabe S1–AC bedeutet zum Beispiel, dass die Scheibe S1 vom Stab A auf den Stab C verschoben wird.
S1–AC.Der Fall n = 2, also mit zwei Scheiben, ist ebenfalls einfach. Zuerst wird die obere kleine Scheibe auf den Stab B gelegt, anschließend die untere größere Scheibe auf den Stab C und abschließend die kleine Scheibe vom Stab B auf den Stab C gelegt. Die Aufgabe wird also durch die folgenden drei Züge gelöst:
Für den Fall n = 3, also mit drei Scheiben, kann folgende Vorüberlegung angestellt werden. Um die größte, also unten liegende, Scheibe nach C bewegen zu können, muss der 2-Stapel (Stapel aus zwei Scheiben) darüber auf B bewegt werden. Um diesen 2-Stapel nach B zu bewegen, muss der 1-Stapel darüber, also die oberste, kleinste Scheibe, zunächst nach C bewegt werden. Anschließend kann die mittlere Scheibe nach B und die kleinste Scheibe von C nach B bewegt werden. Es ergibt sich also die Zugfolge:
S1–AC | S2–AB | S1–CBDiese Zugfolge entspricht also dem Fall mit zwei Scheiben, wobei jedoch die Stäbe B und C vertauschte Rollen spielen.
S3–ACZum Schluss muss der 2-Stapel von der Mitte nach rechts verschoben werden, um die Aufgabe zu lösen. Dies funktioniert genauso wie die Zugfolge am Anfang, nur dass Stab A mit Stab B, Stab B mit Stab C und Stab C mit Stab A vertauschte Rollen spielen. Es bleibt also die Zugfolge:
Allgemein kann für jede zusätzliche Scheibe zuerst der Stapel mit einer Scheibe auf B, dann die unterste Scheibe nach C und anschließend der Stapel von B nach C weiterbewegt werden. Für den Fall n = 4, also mit vier Scheiben, ergibt sich also die Zugfolge mit den 15 Lösungsschritten:
Die Geschichte um die Mönche und die Zugfolgen für kleine Scheibenanzahlen führen mit einem rekursiven Algorithmus zur Lösung des Spiels. Da sich ein Computerprogramm zur Lösung des Spiels mit wenigen Zeilen schreiben lässt, ist Türme von Hanoi ein klassisches Beispiel für diese Art der Problemlösung.
Der Algorithmus besteht im Wesentlichen aus einer Funktion bewege, die vier Parameter besitzt. Mit i ist die Anzahl der zu verschiebenden Scheiben bezeichnet, mit a der Stab von dem verschoben werden soll, mit b der Stab, der als Zwischenziel dient und mit c der Stab, auf den die Scheiben verschoben werden sollen. Zur Lösung des eigentlichen Problems wird bewege mit i = n, a = A, b = B und c = C aufgerufen.
Die Funktion bewege löst ein Teilproblem dadurch, dass es dieses in drei einfachere Probleme aufteilt, sofern der zu verschiebende Turm mindestens die Höhe 1 besitzt. Andernfalls ist die Funktion bewege untätig. Die drei Teilprobleme werden sequentiell ausgeführt. Zunächst wird der um eine Scheibe kleinere Turm von a auf das Zwischenziel b verschoben, indem sich die Funktion bewege selbst mit den entsprechenden Parametern aufruft. Die Stäbe b und c tauschen dabei ihre Rollen. Anschließend wird die einzig verbliebene Scheibe von a nach c verschoben. Zum Abschluss wird der zuvor auf b verschobene Turm auf seinen Bestimmungsort c verschoben, wobei hier a und b die Rollen tauschen.
So verhält sich die Funktion bei drei Scheiben (die Stäbe wurden durchnummeriert, links: a, mitte: b, rechts: c; der Bewegungsablauf ist exakt wie im Bild oben):
Die Korrektheit des Algorithmus ist zwar intuitiv glaubhaft, formal aber nicht trivial beweisbar. Im Wesentlichen müssen zwei Dinge gezeigt werden. Zum einen müssen die Teillösungen korrekt arbeiten. Zum anderen ist zu zeigen, dass diese überhaupt durchgeführt werden können. Schließlich darf keine der Scheiben, die bei Teillösungen nicht betrachtet werden, den Transport verhindern. Dass dem tatsächlich so ist, folgt aus der Eigenschaft, dass die Funktion bewege bei jeder Teillösung immer nur die kleinsten i Scheiben bewegt. Sowohl diese Eigenschaft als auch die Korrektheit der Teillösungen lässt sich durch vollständige Induktion zeigen.
Buneman und Levy haben 1980 einen iterativen Algorithmus beschrieben, der die gleiche Zugfolge generiert. Bei diesem ist die Korrektheit zwar nicht sofort erkennbar, die Handlungsweise aber ohne das Konzept der Rekursion verständlich. Es sei vorausgesetzt, dass die Stäbe A, B und C bei gerader Scheibenanzahl im Uhrzeigersinn auf einem Kreis angeordnet sind, sonst entgegen dem Uhrzeigersinn. Die Scheiben befinden sich zum Anfang alle auf Stab A, am Ende auf Stab C.
Solange sich auf wenigstens einem der beiden Stäbe A und B Scheiben befinden, wird erst die kleinste Scheibe (
Der zweite Zug innerhalb der Schleife ist bis auf den letzten Schleifendurchgang immer möglich und auch eindeutig. Um dies einzusehen, sei der Stab, auf dem 
   liegt mit a und von den beiden verbliebenen Stäben denjenigen mit der kleineren obenaufliegenden Scheibe mit b, der anderen mit c bezeichnet. Offensichtlich kann die oberste Scheibe von b auf c verschoben werden. Dies ist zugleich die einzige Möglichkeit, eine Scheibe verschieden von 
   zu verschieben. Denn weder die oberste Scheibe von b noch von c kann auf a verschoben werden, da dort mit 
   die kleinste Scheibe liegt. Auch ein Verschieben der obersten Scheibe von c nach b ist nach Wahl der Bezeichnungen der Stäbe nicht möglich. Der Fall, dass keine andere Scheibe als 
   verschiebbar ist, tritt nur dann ein, wenn alle Scheiben wieder auf einem Stab liegen, das Ziel also bereits erreicht ist.
Es gibt für jede Scheibenanzahl nur einen optimalen Lösungsweg für das Problem, also nur eine kürzeste Zugfolge. Diese wird von beiden Algorithmen durchlaufen. In diesem Sinne sind die Algorithmen also optimal.
Für den rekursiven Algorithmus lässt sich dies leicht einsehen. Bevor die unterste Scheibe eines (Teil-)Turmes verschoben werden kann, müssen alle darüberliegenden Scheiben auf das Zwischenziel verschoben werden (dort müssen sie natürlich in geordneter Reihenfolge landen). Erst dann kann die unterste Scheibe auf den Zielstab verschoben werden. Denn nur dann liegt diese frei und nur wenn alle ursprünglich über dieser Scheibe liegenden Scheiben auf dem Zwischenziel liegen, kann keine dieser kleineren Scheiben das Verschieben der untersten Scheibe auf das Ziel blockieren.
Für die Optimalität des iterativen Algorithmus genügt es zu zeigen, dass die durch den rekursiven Algorithmus bestimmte Zugfolge den Bedingungen des iterativen Algorithmus genügt. Dies ergibt sich aus der folgenden Überlegung: Das Versetzen eines nichtleeren Teilturmes beginnt und endet jeweils mit einer Bewegung der kleinsten Scheibe. In der rekursiven Funktion wird also unmittelbar vor und unmittelbar nach dem Verschieben der i-ten Scheibe die kleinste Scheibe bewegt. Da jede Bewegung einer Scheibe auf dieser Anweisung beruht und die kleinste Scheibe aufgrund der Optimalität niemals zweimal direkt hintereinander bewegt wird, wird sie in jedem zweiten Zug versetzt. Die zyklische Richtung, in der die beiden Teiltürme in einem Aufruf der Funktion versetzt werden, ist für die beiden rekursiven Aufrufe a–c–b und b–a–c der Funktion dieselbe, nämlich der Richtung a–b–c entgegengesetzt. Infolgedessen ist die zyklische Richtung für alle Aufrufe mit i = 1 dieselbe, das heißt die kleinste Scheibe wird immer in derselben Richtung bewegt. Somit erzeugt der rekursive Algorithmus dieselbe Zugfolge wie der iterative.
Der iterative Algorithmus führt auch dann zur Lösung, wenn die Stäbe falsch herum auf dem Kreis angeordnet werden. Im Falle einer falschen Anordnung werden die Scheiben aber zuerst auf Stab B verschoben. Da in dieser Situation die Abbruchbedingung nicht erfüllt ist, wird anschließend weiter auf C verschoben. Der Algorithmus benötigt in diesem Fall damit doppelt so viele Züge, ist dann also nicht optimal.
Die zuletzt bewegte Scheibe darf nicht gleich noch einmal bewegt werden.Sie sind aber nicht hinreichend, dies zeigt das Beispiel für drei Scheiben mit insgesamt 11 Zügen:
S1–AB | S2–AC | S1–BC | S3–AB | S1–CB | S2–CA | S1–BA | S3–BC | S1–AB | S2–AC | S1–BC.Die oben angegebenen Zugfolgen für kleine Scheibenanzahlen sind optimal, entsprechen also genau den Zugfolgen, die von den Algorithmen erzeugt werden.
Für optimale Zugfolgen lassen sich eine ganze Reihe von Eigenschaften herleiten. Wegen der Optimalität des rekursiven Algorithmus ist dies besonders leicht anhand seiner Funktionsweise möglich.
  . Dies lässt sich leicht induktiv zeigen. Für eine einzelne Scheibe ist dies sicher richtig, denn diese muss nur von A nach C verschoben werden, die optimale Zugfolge besteht also, wie behauptet, aus einem Zug. Für größere Scheibenanzahlen wird die Anzahl der Züge durch Summation der Züge für die Teilprobleme nachgewiesen. Die Zuganzahl entspricht also dem Doppelten der minimalen Zuganzahl für den um eine Scheibe kleineren Turm, da dieser zweimal bewegt werden muss, plus den einen Zug, um die größte Scheibe zu bewegen. Wie behauptet folgt:
  Es lässt sich leicht bestimmen, wie oft und bei welchen Zügen eine Scheibe bei einer optimalen Zugfolge bewegt wird. Allgemein gilt, dass die Scheibe 
   wird zweimal bewegt, und zwar nach dem ersten und dritten Viertel der um 1 erhöhten Zugfolge, also bei den Zügen 
  . Auf diese Weise ist es möglich, an jedem Punkt der Zugfolge zu bestimmen, welche Scheibe als Nächstes bewegt werden muss.
   Züge zur Lösung der Aufgabe benötigt, wobei n die Anzahl der Scheiben ist. Es liegt also ein exponentielles Wachstum der Komplexität des Problems vor. Damit ist eine praktische Umsetzung der Lösung nur für kleine n möglich. Die nebenstehende Tabelle zeigt die Dauer unter der Annahme, dass eine Scheibe pro Sekunde verschoben wird.
Stellt man alle erlaubten Spielzüge in einem Graphen dar, dann erhält man den Spielbaum. Dabei wird jede Spielstellung durch einen Knoten dargestellt und jeder Zug durch eine Kante. Die Beschriftung der Knoten erfolgt anhand der Position der Scheiben, beginnend mit der Position der größten Scheibe 
Die nebenstehende Grafik zeigt den Spielbaum eines Turms der Höhe drei. Die Ecken des Dreiecks mit den Stellungen AAA und CCC entsprechen der Start- bzw. Endposition, die Ecke BBB entspricht der Stellung mit allen Scheiben auf dem mittleren Stab B. Die Kantenfarbe entspricht der der bewegten Scheibe in der Animation oben: Rot für die kleinste, Gelb für die mittlere und Blau für die größte Scheibe 
  , denn jede Scheibe kann sich auf jedem Stab befinden und bei mehreren Scheiben auf demselben Stab ist deren Anordnung aufgrund ihrer Größe eindeutig gegeben.
Sind nicht alle Scheiben auf dem gleichen Stab, darf man zudem noch die nächstkleinere, obenliegende Scheibe bewegen.
Von allen Stellungen aus hat man also drei Zugmöglichkeiten, außer an den Ausgangspositionen AAA, BBB und CCC, in denen nur zwei Züge möglich sind.
    {\displaystyle k_{n}\;=\;{\frac {3\cdot 2\,+\,(3^{n}-3)\cdot 3}{2}}\;=\;{\frac {3}{2}}\,(3^{n}-1)}
  Die Division durch Zwei rührt daher, dass jede Kante zu zwei Knoten gehört. Die Gesamtheit aller Züge ist 
Durch den rekursiven Aufbau des Spielgraphen lässt sich leicht nachweisen, dass der Durchmesser des Graphen gleich 
Erhöht man einen Turm um eine Scheibe, dann wachsen sowohl die Anzahl der Knoten als auch die Anzahl der Kanten seines Spielbaumes in der Größenordnung von 3, während der geometrische Durchmesser in der gewählten Veranschaulichung um den Faktor 2 wächst. Normiert man die Spielbäume auf den Durchmesser Eins, dann strebt die Folge der so normierten Graphen gegen das Sierpinski-Dreieck.
Einführung in die wissenschaftliche Programmierung – Seite 3, Stack-Beispiel: Türme von Hanoi (Vorlesung an der Technischen Universität München)
Lernfunk.de – Demonstration des Algorithmus (Ausschnitt aus der Vorlesung Algorithmen der Universität Osnabrück)
